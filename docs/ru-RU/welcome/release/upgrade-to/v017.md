# Изменения несовместимости в NocoBase 0.17

#### В этой статье рассматриваются только изменения несовместимости, связанные с разработкой плагинов

## Изменения в SchemaInitializer

- Добавлен `SchemaInitializerManager` для регистрации `SchemaInitializer`
- Добавлен `useSchemaInitializerRender()`, чтобы заменить исходный `useSchemaInitializer()` на `render()`.
- Добавлен компонент `useSchemaInitializerItem()` для получения контекста текущего элемента инициализации
- Добавлен компонент `SchemaInitializerItemGroup` в качестве компонента по умолчанию для `type: `ItemGroup`.
- Добавлен компонент `SchemaInitializerSubMenu` в качестве компонента по умолчанию для подменю `type:`
- Добавлен компонент `SchemaInitializerDivider` в качестве компонента по умолчанию для разделителя `type:`
- Добавлен компонент `SchemaInitializerChildren` для пользовательского отображения нескольких элементов списка
- Добавлен компонент `Schemainitializerchildren` для пользовательского отображения одного элемента списка
- Изменены обязанности `SchemaInitializerContext` по сохранению контекста текущего инициализатора
- Изменены обязанности `useSchemaInitializer()` по получению контекста текущего инициализатора.
- Изменен `function SchemaInitializer` на `class SchemaInitializer` для определения инициализатора
- Изменены параметры `SchemaInitializer`
- Добавлен обязательный параметр `имя` для значения `x-инициализатор`
  - Добавлен параметр `Компонент` для пользовательского отображения кнопки. По умолчанию используется `SchemaInitializerButton`.
  - Добавлены `componentProps`, `style` для настройки свойств и стиля `Component`
  - Добавлен параметр `ItemsComponent` для пользовательского отображения списка. По умолчанию используется `SchemaInitializerItems`.
  - Добавлены `itemsComponentProps`, `itemsComponentStyle` для настройки свойств и стиля `ItemsComponent`
  - Добавлен параметр `popover` для настройки отображения эффекта `popover`.
  - Добавлен параметр `useInsert` для случаев, когда функция `insert` должна использовать перехватчики
  - Изменен параметр `dropdown` на "popoverProps", используя `Popover` вместо `Dropdown`
- Изменены параметры `items` для `SchemaInitializer`
  - Добавлена функция `useChildren` для динамического управления дочерними элементами
  - Добавлена функция `componentProps` для свойств самого компонента
- Добавлена функция `useComponentProps` для динамической обработки реквизитов компонента
  - Изменен параметр `key` на `name` для уникальной идентификации элементов списка
  - Изменен параметр `visible` на функцию `useVisible` для динамического управления отображением.
  - Изменен параметр `component` на `Component` для отображения элементов списка
- Изменен параметр `SchemaInitializer.Кнопка на `SchemaInitializerButton`, значение по умолчанию для параметра `Component` в `SchemaInitializer`
- Изменен `SchemaInitializer".Item` в `SchemaInitializerItem` с неизмененными параметрами
- Изменен `SchemaInitializer.ActionModal` на `SchemaInitializerActionModal` с неизменными параметрами
- Изменен `SchemaInitializer.SwitchItem` на `SchemaInitializer.Switch` с неизменными параметрами
- Удален `SchemaInitializerProvider`, заменен на "SchemaInitializerManager`
- Удален `SchemaInitializer.itemWrap`, больше не нужно обертывать компонент `item`

Для получения дополнительной информации обратитесь к следующей документации:

- [Разработка плагина / инициализатор схемы](/development/client/ui-schema/initializer)
- [Документация по API / SchemaInitializer](https://client.docs.nocobase.com/core/ui-schema/schema-component)

### Добавление элементов в существующий инициализатор

Раньше мы получали все `инициализаторы` через `SchemaInitializerContext`, а затем добавляли, удаляли или изменяли их. Например, следующий код добавляет `Hello` к `media` в `BlockInitializers`:

```tsx | pure
const items = useContext<any>(SchemaInitializerContext);
const mediaItems = items.BlockInitializers.items.find(
  (item) => item.key === 'media',
);

if (process.env.NODE_ENV !== 'production' && !mediaItems) {
  throw new Error('media block initializer not found');
}

const children = mediaItems.children;
if (!children.find((item) => item.key === 'hello')) {
  children.push({
    key: 'hello',
    type: 'item',
    title: '{{t("Hello block")}}',
    component: HelloBlockInitializer,
  });
}
```

Новый способ добавления элементов заключается в использовании метода `schemaInitializerManager.addItem()` в методе загрузки плагина.

```tsx | pure
class MyPlugin extends Plugin {
  async load() {
    this.schemaInitializerManager.addItem(
      'BlockInitializers',
      'otherBlocks.hello',
      {
        title: '{{t("Hello block")}}',
        Component: HelloBlockInitializer,
      },
    );
  }
}
```

Подробная ссылка на документацию

- [Разработка плагина / Инициализатор схемы / Добавление элементов к существующему инициализатору](/development/client/ui-schema/initializer)
- [Документация по API / SchemaInitializer / Встроенные компоненты и типы](https://client.docs.nocobase.com/core/ui-schema/schema-initializer)

### Добавьте новый инициализатор в приложение

Добавленный ранее с помощью `SchemaInitializerProvider`, например:

```tsx | pure
<SchemaInitializerProvider
  initializers={{ BlockInitializers }}
  components={{ ManualActionDesigner }}
></SchemaInitializerProvider>
```

Теперь добавьте его в загрузку плагина, например:

```tsx | pure
import { Plugin } from '@nocobase/client';

class MyPlugin extends Plugin {
  async load() {
    this.app.schemaInitializerManager.add(blockInitializers);
    this.app.addComponents({ ManualActionDesigner });
  }
}
```

Для получения подробной документации обратитесь к:

- [Разработка плагина / Инициализатор схемы / Добавление нового инициализатора](/development/client/ui-schema/initializer)
- [API Documentation / SchemaInitializerManager / schemaInitializerManager.addItem()](https://client.docs.nocobase.com/core/ui-schema/schema-initializer-manager)

### Добавить новый инициализатор

Если раньше `SchemaInitializer` поддерживал запись объектов и компонентов в формате JSON, то теперь используется только `new SchemaInitializer()`.

Пример 1: Старый способ записи JSON изменен на `new SchemaInitializer()`.

```diff
- export const BlockInitializers = {
+ export const blockInitializers = new SchemaInitializer({
+ name: 'BlockInitializers',
  'data-testid': 'add-block-button-in-page',
  title: '{{t("Add block")}}',
  icon: 'PlusOutlined',
  wrap: gridRowColWrap,
   items: [
    {
-     key: 'dataBlocks',
+     name: 'data-blocks',
      type: 'itemGroup',
      title: '{{t("Data blocks")}}',
      children: [
        {
-         key: 'table',
+         name: 'table',
-         type: 'item',
          title: '{{t("Table")}}',
-         component: TableBlockInitializer,
+         Component: TableBlockInitializer,
        },
         {
          key: 'form',
          type: 'item',
          title: '{{t("Form")}}',
          component: FormBlockInitializer,
        }
      ],
    },
  ],
});
```

Пример 2. Измените способ записи компонента на `new SchemaInitializer()`.

Оказывается, это способ определения компонентов:

```tsx | pure
export const BulkEditFormItemInitializers = (props: any) => {
  const { t } = useTranslation();
  const { insertPosition, component } = props;
  const associationFields = useAssociatedFormItemInitializerFields({
    readPretty: true,
    block: 'Form',
  });
  return (
    <SchemaInitializer.Button
      data-testid="configure-fields-button-of-bulk-edit-form-item"
      wrap={gridRowColWrap}
      icon={'SettingOutlined'}
      items={[
        {
          type: 'itemGroup',
          title: t('Display fields'),
          children: useCustomBulkEditFormItemInitializerFields(),
        },
        {
          type: 'divider',
        },
        {
          type: 'item',
          title: t('Add text'),
          component: BlockItemInitializer,
        },
      ]}
      insertPosition={insertPosition}
      component={component}
      title={component ? null : t('Configure fields')}
    />
  );
};
```

Теперь его нужно изменить на подход `new SchemaInitializer()`:

```tsx | pure
const bulkEditFormItemInitializers = new SchemaInitializer({
  name: 'BulkEditFormItemInitializers',
  'data-testid': 'configure-fields-button-of-bulk-edit-form-item',
  wrap: gridRowColWrap,
  icon: 'SettingOutlined',
  // 原 insertPosition 和 component 是透传的，这里不用管，也是透传的
  items: [
    {
      type: 'itemGroup',
      title: t('Display fields'),
      name: 'displayFields', // 记得加上 name
      useChildren: useCustomBulkEditFormItemInitializerFields, // 使用到了 useChildren
    },
    {
      type: 'divider',
    },
    {
      title: t('Add text'),
      name: 'addText',
      Component: BlockItemInitializer, // component 替换为 Component
    },
  ],
});
```

Для получения подробной документации обратитесь к:

- [Разработка плагина / Инициализатор схемы / Добавление нового инициализатора](/development/client/ui-schema/initializer)
- [API Documentation / SchemaInitializer / new SchemaInitializer(options)](https://client.docs.nocobase.com/core/ui-schema/schema-initializer)

### Определение и реализация элемента

Ранее при настройке элемента реквизиты компонентов размещались в элементе, но теперь рекомендуется использовать `componentProps` и `useComponentProps`.

```diff
{
 name: 'BlockInitializers',
 items: [
  {
    name: 'xxx',
    Component: XXXSchemaInitializerItem,
    title: 'Title 1',
    schema: {},
-   foo: 'bar',
+   useComponentProps: () => {
+     return { foo: 'bar' }
+   }
  }
 ]
}
```

В компоненте `Item` конфигурация элемента раньше передавалась напрямую с помощью props, но теперь она получается с помощью `useSchemaInitializerItem()`, и включены соответствующие перехватчики:

- `useSchemaInitializer()` чтобы получить текущий контекст инициализатора.
- `useSchemaInitializerItem()` возвращает контекст текущего элемента.

```diff
const XXXSchemaInitializerItem = (props) => {
-  const { insert, title, schema, foo } = props;
+  const { foo } = props;
+  const { insert } = useSchemaInitializer();
+  const { title, schema } = useSchemaInitializerItem();
 // ...
}
```

Подробная ссылка на документацию

- [API Documentation / SchemaInitializer / Built-in Components and Types](https://client.docs.nocobase.com/core/ui-schema/schema-initializer)

## Изменения в SchemaSettings

### Новые добавления
- Добавлен `SchemaSettingsManager` для регистрации настроек `SchemaSettings`
- Добавлен хук `useSchemaSettingsItem()`
- Добавлен хук `useSchemaSettingsRender()` 
- Добавлен параметр `x-settings` для конфигурации настроек схемы
- Добавлен параметр `x-toolbar` для настройки панели инструментов схемы
- Добавлен компонент `SchemaToolbar` для кастомизации панели инструментов
- Добавлен хук `useSchemaToolbarRender()` для замены оригинального `useDesigner()`

### Изменения структуры
- Изменена реализация `function SchemaSettings` → `class SchemaSettings`
- Оригинальный `SchemaSettings` переименован в `SchemaSettingsDropdown`

### Переименованные компоненты
- `SchemaSettings.Item` → `SchemaSettingsItem`
- `SchemaSettings.ItemGroup` → `SchemaSettingsItemGroup`  
- `SchemaSettings.SubMenu` → `SchemaSettingsSubMenu`
- `SchemaSettings.Divider` → `SchemaSettingsDivider`
- `SchemaSettings.Remove` → `SchemaSettingsRemove`
- `SchemaSettings.SelectItem` → `SchemaSettingsSelectItem`
- `SchemaSettings.CascaderItem` → `SchemaSettingsCascaderItem`
- `SchemaSettings.SwitchItem` → `SchemaSettingsSwitchItem`
- `SchemaSettings.ModalItem` → `SchemaSettingsModalItem`
- `SchemaSettings.ActionModalItem` → `SchemaSettingsActionModalItem`

### Удаленные элементы
- Удален параметр `x-designer` (устарел, используйте `x-toolbar`)
- Удален хук `useDesigner()` (устарел, используйте `useSchemaToolbarRender()`)

Сопутствующая документация:

- [Разработка плагинов / Настройки схем](/development/client/ui-schema/initializer)
- [Плагины / Панель инструментов SchemaToolbar](/development/client/ui-schema/initializer)
- [Документация по API / Настройки схем](https://client.docs.nocobase.com/core/ui-schema/schema-component)
- [API Documentation / SchemaSettingsManager](https://client.docs.nocobase.com/core/ui-schema/schema-component)
- [API Documentation / SchemaToolbar](https://client.docs.nocobase.com/core/ui-schema/schema-component)

### Определение и реализация настроек

Ранее `SchemaSettings` была реализована с помощью `GeneralSchemaDesigner` и использовалась в `x-designer`.

```tsx | pure
<GeneralSchemaDesigner>
  <SchemaSettings.SwitchItem
    title={'Enable Header'}
    onClick={() => {}}
  ></SchemaSettings.SwitchItem>
  <SchemaSettings.Divider />
  <SchemaSettings.ModalItem
    title={'xxx'}
    schema={}
    onSubmit={props.onSubmit}
  ></SchemaSettings.ModalItem>
</GeneralSchemaDesigner>
```

Теперь разделите их на `x-панель инструментов` и `x-настройки`, при этом `x-панель инструментов` отсутствует, а настройки схем используются в `x-настройках`.

```ts
const mySettings = new SchemaSettings({
  name: 'MySettings',
  items: [
    {
      name: 'enableHeader',
      type: 'switch',
      componentProps: {
        title: 'Enable Header',
        onClick: () => {},
      },
    },
    {
      name: 'divider',
      type: 'divider',
    },
    {
      name: 'xxx',
      type: 'modal',
      useComponentProps() {
        // useSchemaDesigner() 会传入 props
        const { onSubmit } = useSchemaDesigner();
        return {
          title: 'xxx',
          schema: {},
          onSubmit,
        };
      },
    },
  ],
});
```

Изменения в схеме

```diff
{
  type: 'void',
- 'x-designer': 'CustomButton.Designer'
+ 'x-toolbar': 'CustomButtonToolbar',  // 非必须
+ 'x-settings': 'CustomButtonSettings',
  'x-component': 'CustomButton',
  'x-content': 'Hello2',
}
```

### Реализация элемента для настроек

Предыдущую версию компонента `Item` было очень сложно реализовать, но теперь мы используем `useSchemaSettings()`, чтобы получить значение `Designable` для текущей схемы, и используем значение `Designable` для изменения текущей схемы.

```diff
function EditBlockTitle(props) {
- const field = useField();
- const fieldSchema = useFieldSchema();
- const { dn } = useDesignable();
+ const { dn } = useSchemaSettings();

  return (
    <SchemaSettings.ModalItem
      title={'Edit block title'}
      schema={
        {
          type: 'object',
          title: 'Edit block title',
          properties: {
            title: {
              title: 'Block title',
              type: 'string',
              // 获取 schema 的默认值
-             default: fieldSchema?.['x-decorator-props']?.title,
+             default: dn.getSchemaAttribute('x-decorator-props.title'),
              'x-decorator': 'FormItem',
              'x-component': 'Input',
              'x-compile-omitted': ['default'],
            },
          },
        } as ISchema
      }
      onSubmit={({ title }) => {
-       field.decoratorProps.title = title;
-       fieldSchema['x-decorator-props'] = fieldSchema['x-decorator-props'] || {};
-       fieldSchema['x-decorator-props'].title = title;
-       dn.emit('patch', {
-         schema: {
-           ['x-uid']: fieldSchema['x-uid'],
-           'x-decorator-props': {
-             ...fieldSchema['x-decorator-props'],
-           },
-         },
-       });
-       dn.refresh();
+       dn.deepMerge({
+         'x-decorator-props': {
+           title,
+         },
+       });
      }}
    />
  );
}
```

Ссылка на соответствующую документацию:

- [Разработка плагинов / Настройка параметров схемы / Как реализовать настройки схемы](/development/client/ui-schema/settings)
- [Разработка плагинов / Настраиваемый дизайнер](/development/client/ui-schema/designable)
- [Ссылки на API / Настройки схем / Встроенные компоненты и типы](https://client.docs.nocobase.com/core/ui-schema/schema-settings)
- [Ссылка на API / Возможность разработки](https://client.docs.nocobase.com/core/ui-schema/designable)

## Другое

### app.addComponent способ приватизации

The `app.addComponent` method is privatized and no longer exposed to the public, you need to register the component via the `app.addComponents` method.

```diff
- app.addComponent(MyComponent, 'MyComponent')
+ app.addComponents({ MyComponent })
```

### Удалите `PluginManagerContext`.

```diff
const MyProvider = props => {
- const ctx = useContext(PluginManagerContext);
return <div>
- <PluginManagerContext.Provider value={{components: { ...ctx?.components }}}>
  {/* ... */}
- </PluginManagerContext.Provider>
</div>
}
```
