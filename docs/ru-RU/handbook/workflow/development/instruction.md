# Расширение типов узлов

Тип узла по сути представляет собой операционную команду, где разные команды соответствуют разным операциям, выполняемым в рабочем процессе.

Как и в случае с триггерами, расширение типа узла включает в себя как серверную, так и клиентскую части. Серверная часть отвечает за реализацию логики зарегистрированных команд, а клиентская предоставляет интерфейс для настройки параметров узла, где находится команда.

## Серверная часть

### Простейшая команда узла

Ядро команды — это функция, то есть в классе команды должен быть реализован метод `run` для выполнения логики команды. Эта функция может выполнять любые необходимые операции, такие как операции с базой данных, файловые операции или вызовы сторонних API.

Все команды должны наследоваться от базового класса `Instruction`. Простейшая команда требует только реализации функции `run`:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class MyInstruction extends Instruction {
  run(node, input, processor) {
    console.log('моя команда выполняется!');
    return {
      status: JOB_STATUS.RESOLVED,
    };
  }
}
```

Затем зарегистрируйте эту команду в плагине рабочих процессов:

```ts
export default class MyPlugin extends Plugin {
  load() {
    // получение экземпляра плагина рабочих процессов
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // регистрация команды
    workflowPlugin.registerInstruction('my-instruction', MyInstruction);
  }
}
```

Значение статуса (`status`) в возвращаемом объекте команды обязательно и должно быть одним из значений константы `JOB_STATUS`. Это значение определяет последующий поток процесса после выполнения узла. Обычно используется `JOB_STATUS.RESOLVED`, что означает успешное выполнение узла и продолжение выполнения последующих узлов. Если есть результаты, которые нужно сохранить заранее, можно также вызвать метод `processor.saveJob` и вернуть объект, сгенерированный этим методом. Исполнитель создаст запись результата выполнения на основе этого объекта.

### Результаты узла

Если есть конкретный результат выполнения, особенно данные, предназначенные для использования последующими узлами, их можно вернуть через атрибут `result` и сохранить в объекте задачи узла:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class RandomStringInstruction extends Instruction {
  run(node, input, processor) {
    // пользовательская конфигурация из узла
    const { digit = 1 } = node.config;
    const result = `${Math.round(10 ** digit * Math.random())}`.padStart(
      digit,
      '0',
    );
    return {
      status: JOB_STATUS.RESOLVED,
      result,
    };
  }
};
```

`node.config` — это элемент конфигурации узла, который может быть любым требуемым значением и будет сохранен как поле типа `JSON` в соответствующей записи узла в базе данных.

### Обработка ошибок команды

Если во время выполнения могут возникнуть исключения, их можно перехватить заранее и вернуть статус ошибки:

```ts
import { JOB_STATUS } from '@nocobase/plugin-workflow';

export const errorInstruction = {
  run(node, input, processor) {
    try {
      throw new Error('исключение');
    } catch (error) {
      return {
        status: JOB_STATUS.ERROR,
        result: error,
      };
    }
  },
};
```

Если предсказуемые исключения не перехвачены, движок рабочих процессов автоматически перехватит их и вернет статус ошибки, чтобы избежать сбоев программы из-за неперехваченных исключений.

### Асинхронные узлы

Когда необходимо управлять потоком или выполнять асинхронные (долгие) операции ввода-вывода, метод `run` может вернуть объект со статусом `JOB_STATUS.PENDING`, указывая исполнителю на необходимость ожидания (приостановки) до завершения какой-либо внешней асинхронной операции, после чего движок рабочих процессов будет уведомлен о продолжении выполнения. Если в функции `run` возвращается статус ожидания, команда должна реализовать метод `resume`; иначе рабочий процесс не сможет возобновиться.

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class PayInstruction extends Instruction {
  async run(node, input, processor) {
    // задача может быть создана сначала через processor
    const job = await processor.saveJob({
      status: JOB_STATUS.PENDING,
    });

    const { plugin } = processor;
    // выполнить оплату асинхронно
    paymentService.pay(node.config, (result) => {
      // уведомить processor о возобновлении задачи
      return plugin.resume(job.id, result);
    });

    // вернуть созданный экземпляр задачи
    return job;
  }

  resume(node, job, processor) {
    // проверить статус оплаты
    job.set('status', job.result.status === 'ok' ? JOB_STATUS.RESOLVED : JOB_STATUS.REJECTED);
    return job;
  }
};
```

`paymentService` относится к платежному сервису, и рабочий процесс возобновляет соответствующую задачу после срабатывания обратного вызова от сервиса, в то время как текущий процесс сначала завершается. После этого движок рабочих процессов создает новый процессор, передавая задачу методу `resume` узла для продолжения выполнения ранее приостановленного узла.

"Асинхронные операции", упомянутые здесь, не совпадают с `async`-функциями в JavaScript, а относятся к взаимодействию с другими внешними системами, где определенные операции могут возвращать результат не сразу. Например, платежный сервис может потребовать ожидания последующего уведомления для получения результата.

### Статус результата узла

Статус выполнения узла влияет на успех или неудачу всего рабочего процесса. В целом, при отсутствии ветвления, сбой одного узла напрямую приводит к сбою всего процесса. Наиболее распространённый сценарий — при успешном выполнении узла, следующий узел в последовательности продолжает выполнение, и так до тех пор, пока не останется последующих узлов. В этом случае рабочий процесс завершается со статусом «успешно».

Если во время выполнения узел возвращает статус «ошибка», движок обработает это в зависимости от двух следующих ситуаций:

1.  Если узел, вернувший статус ошибки, находится в основном процессе и не входит в какую-либо ветвь, созданную вышестоящим узлом, весь основной процесс будет считаться неудачным, и процесс завершится.

2.  Если узел, вернувший статус ошибки, находится внутри ветви, ответственность за определение следующего состояния процесса переходит к узлу, который создал эту ветвь. Внутренняя логика этого узла определит последующее состояние процесса, рекурсивно возвращаясь к основному процессу.

В конечном итоге, итоговое состояние всего процесса определяется узлом в основном процессе. Если этот узел возвращает статус «ошибка», весь процесс завершается с соответствующим статусом.

Если любой узел возвращает статус «в ожидании» (pending) после выполнения, весь процесс временно приостанавливается и ожидает события, определённого соответствующим узлом, чтобы возобновить выполнение. Например, в [ручном узле](../manual/nodes/manual) процесс останавливается на этом узле со статусом «в ожидании» и ждёт ручного вмешательства — чтобы решить, продолжать ли выполнение. Если пользователь введёт статус «одобрено», последующие узлы продолжат выполнение; в противном случае, обработка пойдёт по логике ошибки, как описано выше.

Для получения дополнительной информации о возвращаемых статусах команд см. раздел [Справочник API рабочего процесса](./api#JOB_STATUS).

### Досрочное завершение

В некоторых особых процессах может потребоваться завершить процесс непосредственно внутри определённого узла. Это можно сделать, вернув значение `null`. Это означает, что текущий процесс завершается, и последующие узлы выполняться не будут.

Такая ситуация чаще всего встречается в узлах, управляющих потоком выполнения, например, в [узле параллельной ветви](../manual/nodes/parallel) (см. [исходный код](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow-parallel/src/server/ParallelInstruction.ts#L87)). Текущий процесс узла завершается, но для каждой подветви создаются новые процессы, которые продолжают своё выполнение.

:::warn{title=Совет}
Создание ветвей с помощью расширенных узлов — сложная задача, требующая тщательной обработки и полного тестирования.
:::

### Узнать больше

Для детального описания каждого параметра при определении типов узлов см. раздел [Справочник API рабочего процесса](./api#instruction).

## Фронтенд

Как и в случае с триггерами, форма конфигурации команды (типа узла) должна быть реализована на стороне клиента.

### Самый простой узел

Все команды должны быть унаследованы от базового класса `Instruction`, используя соответствующие свойства и методы для настройки и использования узла.

Например, необходимо предоставить интерфейс конфигурации для узла типа «случайная строка чисел» (`randomString`), определённого на сервере. У этого узла есть параметр `digit`, обозначающий количество цифр в случайном числе. В форме конфигурации мы используем поле ввода числа для получения данных от пользователя.

```tsx | pure
import WorkflowPlugin, { Instruction, VariableOption } from '@nocobase/workflow/client';

class MyInstruction extends Instruction {
  title = 'Случайная строка чисел';
  type = 'randomString';
  group = 'extended';
  fieldset = {
    'digit': {
      type: 'number',
      title: 'Количество цифр',
      name: 'digit',
      'x-decorator': 'FormItem',
      'x-component': 'InputNumber',
      'x-component-props': {
        min: 1,
        max: 10,
      },
      default: 6,
    },
  };
  useVariables(node, options): VariableOption {
    return {
      value: node.key,
      label: node.title,
    };
  }
}

export default class MyPlugin extends Plugin {
  load() {
    // получаем экземпляр плагина workflow
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // регистрируем инструкцию
    workflowPlugin.registerInstruction('log', LogInstruction);
  }
}
```

Совет:

Идентификатор типа узла, зарегистрированный на стороне клиента, должен совпадать с идентификатором на сервере, иначе возникнут ошибки.

# Предоставление результатов узла в качестве переменных

Обратите внимание на метод `useVariables` в примере выше. Если результат узла (часть `result`) должен использоваться последующими узлами в качестве переменной, этот метод должен быть реализован в производном классе команды, возвращая объект, соответствующий типу `VariableOption`. Этот объект описывает структуру результата выполнения узла, предоставляя сопоставление имен переменных для выбора и использования в последующих узлах.

Тип `VariableOption` определяется следующим образом:

```ts
export type VariableOption = {
  value?: string;
  label?: string;
  children?: VariableOption[] | null;
  [key: string]: any;
};
```

Ключевой атрибут — `value`, представляющий сегментированное значение пути имени переменной, `label` для отображения в интерфейсе и `children` для представления многоуровневой структуры переменных, когда результат узла является глубоким объектом.

Используемая переменная выражается внутри системы как строка шаблона пути, разделенная `.`. Например, `{{jobsMapByNodeKey.2dw92cdf.abc}}`. Здесь `$jobsMapByNodeKey` представляет набор результатов всех узлов (определено внутренне, не требует обработки), `2dw92cdf` — это `key` узла, а `abc` — пользовательский атрибут в объекте результата узла.

Кроме того, поскольку результат узла может быть простым значением, первый уровень **обязательно** должен быть описанием узла:

```ts
{
  value: node.key,
  label: node.title,
}
```

То есть первый уровень — это `key` и заголовок узла. Например, в [ссылке на код](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow/src/client/nodes/calculation.tsx#L77) узла вычисления, опции в интерфейсе при использовании результата узла вычисления выглядят следующим образом:

![Результат узла вычисления](https://static-docs.nocobase.com/20240514230014.png)

Когда результат узла является сложным объектом, можно использовать `children` для дальнейшего описания атрибутов глубокого уровня. Например, пользовательская команда возвращает следующие данные JSON:

```json
{
  "message": "ok",
  "data": {
    "id": 1,
    "name": "test",
  }
}
```

Тогда метод `useVariables` может вернуть:

```ts
useVariables(node, options): VariableOption {
  return {
    value: node.key,
    label: node.title,
    children: [
      {
        value: 'message',
        label: 'Сообщение',
      },
      {
        value: 'data',
        label: 'Данные',
        children: [
          {
            value: 'id',
            label: 'ID',
          },
          {
            value: 'name',
            label: 'Имя',
          },
        ],
      },
    ],
  };
}
```

Таким образом, следующий интерфейс можно использовать для выбора среди переменных в последующих узлах:

![Сопоставленные переменные результата](https://static-docs.nocobase.com/20240514230103.png)

:::info{title="Совет"}
Когда структура в результате является массивом глубоких объектов, `children` также можно использовать для описания пути, но он не может содержать индексы массива. Это связано с тем, что в обработке переменных рабочего процесса NocoBase описание пути переменной для массивов объектов автоматически преобразуется в массив глубоких значений, и индексы массива не могут использоваться для доступа к конкретному значению. Вы можете обратиться к содержимому в разделе "Рабочий процесс: Расширенное использование" в [Расширенных переменных](../manual/advanced#Использование-переменных).
:::

### Доступность узла

По умолчанию узлы могут быть добавлены в рабочие процессы произвольно. Однако в некоторых случаях узлы могут не подходить для определенных типов рабочих процессов или ветвей. В таких случаях можно использовать метод `isAvailable` для настройки доступности узлов:

```ts
// Определение типа
export abstract class Instruction {
  isAvailable?(ctx: NodeAvailableContext): boolean;
}

export type NodeAvailableContext = {
  // экземпляр плагина рабочего процесса
  engine: WorkflowPlugin;
  // экземпляр текущего рабочего процесса
  workflow: object;
  // вышестоящий узел
  upstream: object;
  // узел как начало ветви (номер индекса ветви)
  branchIndex: number;
};
```

Метод `isAvailable` возвращает `true`, когда узел доступен, и `false`, когда недоступен. Параметр `ctx` содержит контекстную информацию текущего узла, которую можно использовать для определения доступности узла.

В большинстве случаев метод `isAvailable` не нужно реализовывать, и узел доступен по умолчанию. Наиболее частая необходимость в этой настройке возникает, когда узел может быть операцией с высокой стоимостью и не подходит для рабочего процесса в синхронном процессе. В этом случае метод `isAvailable` можно использовать для ограничения использования узла. Например:

```ts
isAvailable({ engine, workflow, upstream, branchIndex }) {
  return !engine.isWorkflowSync(workflow);
}
```

### Узнать больше

Подробное определение каждого параметра при определении типов узлов можно найти в разделе [Справочник API рабочего процесса](./api#instruction-1).
