# Extend Node Type

The type of a node essentially represents an operation command, with different commands corresponding to different operations performed during a workflow.

Similar to triggers, extending the type of a node involves both backend and frontend components. The backend is responsible for implementing the logic of registered commands, while the frontend provides the configuration interface for the parameters related to the node where the command resides.

## Backend

### The Simplest Node Command

The core of a command is a function, meaning the `run` method in the command class must be implemented to execute the command's logic. This function can perform any necessary operations, such as database operations, file operations, or third-party API calls.

All commands must be derived from the `Instruction` base class. The simplest command only needs to implement a `run` function:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class MyInstruction extends Instruction {
  run(node, input, processor) {
    console.log('my instruction runs!');
    return {
      status: JOB_STATUS.RESOLVED,
    };
  }
}
```

Then, register this command with the workflow plugin:

```ts
export default class MyPlugin extends Plugin {
  load() {
    // get workflow plugin instance
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // register instruction
    workflowPlugin.registerInstruction('my-instruction', MyInstruction);
  }
}
```

The status value (`status`) in the returned object of the command is mandatory and must be one of the values in the `JOB_STATUS` constant. This value will determine the subsequent flow of the process after the node is executed. Generally, `JOB_STATUS.RESOLVED` is used, indicating that the node has been successfully executed, and the subsequent nodes will continue to execute. If there are results that need to be saved early, you can also call the `processor.saveJob` method and return the object generated by this method. The executor will generate an execution result record based on this object.

### Node Result Values

If there is a specific execution result, especially data intended for use by subsequent nodes, it can be returned through the `result` attribute and saved in the node task object:

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class RandomStringInstruction extends Instruction {
  run(node, input, processor) {
    // customized config from node
    const { digit = 1 } = node.config;
    const result = `${Math.round(10 ** digit * Math.random())}`.padStart(
      digit,
      '0',
    );
    return {
      status: JOB_STATUS.RESOLVED,
      result,
    };
  }
};
```

The `node.config` is the node's configuration item, which can be any required value and will be saved as a `JSON` type field in the corresponding node record in the database.

### Command Error Handling

If there may be exceptions during execution, they can be caught in advance and a failure status returned:

```ts
import { JOB_STATUS } from '@nocobase/plugin-workflow';

export const errorInstruction = {
  run(node, input, processor) {
    try {
      throw new Error('exception');
    } catch (error) {
      return {
        status: JOB_STATUS.ERROR,
        result: error,
      };
    }
  },
};
```

If predictable exceptions are not caught, the workflow engine will automatically catch and return an error status to avoid program crashes due to uncaught exceptions.

### Asynchronous Nodes

When it is necessary to control the flow or perform asynchronous (time-consuming) I/O operations, the `run` method can return an object with a `status` of `JOB_STATUS.PENDING`, indicating to the executor to wait (suspend) until some external asynchronous operation is completed, after which the workflow engine will be notified to continue execution. If a pending status is returned in the `run` function, the command must implement the `resume` method; otherwise, the workflow cannot resume.

```ts
import { Instruction, JOB_STATUS } from '@nocobase/plugin-workflow';

export class PayInstruction extends Instruction {
  async run(node, input, processor) {
    // job could be created first via processor
    const job = await processor.saveJob({
      status: JOB_STATUS.PENDING,
    });

    const { plugin } = processor;
    // do payment asynchronously
    paymentService.pay(node.config, (result) => {
      // notify processor to resume the job
      return plugin.resume(job.id, result);
    });

    // return created job instance
    return job;
  }

  resume(node, job, processor) {
    // check payment status
    job.set('status', job.result.status === 'ok' ? JOB_STATUS.RESOLVED : JOB_STATUS.REJECTED);
    return job;
  }
};
```

The `paymentService` refers to a payment service, and the workflow resumes the corresponding task after being triggered by a callback from the service, while the current process exits first. After that, the workflow engine creates a new processor, handing over the task to the node’s `resume` method to continue executing the previously suspended node.

:::info{title=Tip}
The "asynchronous operations" mentioned here are not the same as `async` functions in JavaScript but refer to interactions with other external systems where certain operations may not return immediately. For example, a payment service may require waiting for a subsequent notification to know the result.
:::

### Node Result Status

The execution status of a node affects the success or failure of the entire process. Generally, in the absence of branches, a node failure will directly lead to the failure of the entire process. The most common scenario is that when a node is successfully executed, the next node in the node table continues until there are no more subsequent nodes, at which point the workflow completes with a successful status.

If a node returns a failure status during execution, the engine will handle it differently depending on the following two situations:

1.  If the node that returns a failure status is in the main process and not within any branch process opened by an upstream node, the entire main process will be considered a failure, and the process will exit.

2.  If the node that returns a failure status is within a branch process, the responsibility for determining the next state of the process is delegated to the node that opened the branch. The internal logic of that node will decide the subsequent state of the process, recursively tracing back to the main process.

Eventually, the final state of the entire process will be determined by the node in the main process. If the node in the main process returns a failure, the entire process ends with a failure status.

If any node returns a "pending" status after execution, the entire execution process will be temporarily suspended, waiting for an event defined by the corresponding node to resume the process. For example, in a [manual node](../manual/nodes/manual), the process pauses at this node with a "pending" status, waiting for manual intervention to decide whether to proceed. If the status input by the user is "approved," the subsequent nodes continue; otherwise, the failure logic is processed as described earlier.

For more command return statuses, refer to the [Workflow API Reference](./api#JOB_STATUS) section.

### Early Exit

In some special processes, it may be necessary to end the process directly within a certain node, which can be done by returning `null`. This indicates that the current process is exited, and the subsequent nodes will not continue to execute.

This situation is more common in flow control-type nodes, such as in the [parallel branch node](../manual/nodes/parallel) (see [code reference](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow-parallel/src/server/ParallelInstruction.ts#L87)). The current node process exits, but new processes are opened for each sub-branch and continue to execute.

:::warn{title=Tip}
Scheduling branch processes with extended nodes is complex and requires careful handling and thorough testing.
:::

### Learn More

For a detailed definition of each parameter in defining node types, refer to the [Workflow API Reference](./api#instruction) section.

## Frontend

Similar to triggers, the configuration form of a command (node type) needs to be implemented on the frontend.

### A Simplest Node

All commands must be derived from the `Instruction` base class, with relevant properties and methods used to configure and utilize the node.

For example, we need to provide a configuration interface for the random number string type (`randomString`) node defined on the backend. This node has a configuration item `digit` representing the number of digits in the random number. In the configuration form, we use a number input box to accept user input.

```tsx | pure
import WorkflowPlugin, { Instruction, VariableOption } from '@nocobase/workflow/client';

class MyInstruction extends Instruction {
  title = 'Random number string';
  type = 'randomString';
  group = 'extended';
  fieldset = {
    'digit': {
      type: 'number',
      title: 'Digit',
      name: 'digit',
      'x-decorator': 'FormItem',
      'x-component': 'InputNumber',
      'x-component-props': {
        min: 1,
        max: 10,
      },
      default: 6,
    },
  };
  useVariables(node, options): VariableOption {
    return {
      value: node.key,
      label: node.title,
    };
  }
}

export default class MyPlugin extends Plugin {
  load() {
    // get workflow plugin instance
    const workflowPlugin = this.app.getPlugin<WorkflowPlugin>(WorkflowPlugin);

    // register instruction
    workflowPlugin.registerInstruction('log',

 LogInstruction);
  }
}
```

:::info{title=Tip}
The node type identifier registered on the client side must be consistent with the one on the server side; otherwise, errors will occur.
:::

### Providing Node Results as Variables

Notice the `useVariables` method in the example above. If the result of a node (`result` part) needs to be used as a variable by subsequent nodes, this method should be implemented in the derived command class, returning an object that conforms to the `VariableOption` type. This object describes the structure of the node’s run result, providing variable name mapping for selection and use in subsequent nodes.

The `VariableOption` type is defined as follows:

```ts
export type VariableOption = {
  value?: string;
  label?: string;
  children?: VariableOption[] | null;
  [key: string]: any;
};
```

The core attribute is `value`, representing the segmented path value of the variable name, `label` for displaying on the interface, and `children` for representing a multi-level variable structure when the node’s result is a deep object.

A usable variable is expressed internally in the system as a path template string separated by `.`. For example, `{{jobsMapByNodeKey.2dw92cdf.abc}}`. Here, `$jobsMapByNodeKey` represents the result set of all nodes (internally defined, no need to handle), `2dw92cdf` is the node’s `key`, and `abc` is a custom attribute in the node’s result object.

Additionally, since the node’s result can also be a simple value, the first layer **must** be the node's description:

```ts
{
  value: node.key,
  label: node.title,
}
```

That is, the first layer is the `key` and title of the node. For example, in the calculation node's [code reference](https://github.com/nocobase/nocobase/blob/main/packages/plugins/%40nocobase/plugin-workflow/src/client/nodes/calculation.tsx#L77), the options on the interface when using the result of the calculation node are as follows:

![Calculation Node Result](https://static-docs.nocobase.com/20240514230014.png)

When the node result is a complex object, you can use `children` to continue describing the deep-level attributes. For example, a custom command returns the following JSON data:

```json
{
  "message": "ok",
  "data": {
    "id": 1,
    "name": "test",
  }
}
```

Then the `useVariables` method can return:

```ts
useVariables(node, options): VariableOption {
  return {
    value: node.key,
    label: node.title,
    children: [
      {
        value: 'message',
        label: 'Message',
      },
      {
        value: 'data',
        label: 'Data',
        children: [
          {
            value: 'id',
            label: 'ID',
          },
          {
            value: 'name',
            label: 'Name',
          },
        ],
      },
    ],
  };
}
```

This way, the following interface can be used to select among the variables in subsequent nodes:

![Mapped Result Variables](https://static-docs.nocobase.com/20240514230103.png)

:::info{title="Tip"}
When a structure in the result is a deep object array, `children` can also be used to describe the path, but it cannot contain array indices. This is because, in NocoBase workflow variable handling, the variable path description for object arrays is automatically flattened into an array of deep values, and array indices cannot be used to access a specific value. You can refer to the content in the "Workflow: Advanced Usage" section of [Advanced Variables](../manual/advanced#Using Variables).
:::

### Node Availability

By default, nodes can be added to workflows at will. However, in some cases, nodes may not be suitable for certain types of workflows or branches. In such cases, the `isAvailable` method can be used to configure the availability of nodes:

```ts
// Type definition
export abstract class Instruction {
  isAvailable?(ctx: NodeAvailableContext): boolean;
}

export type NodeAvailableContext = {
  // instance of workflow plugin
  engine: WorkflowPlugin;
  // instance of current workflow
  workflow: object;
  // upstream node
  upstream: object;
  // node as branch start (branch index number)
  branchIndex: number;
};
```

The `isAvailable` method returns `true` when the node is available and `false` when it is not. The `ctx` parameter contains the context information of the current node, which can be used to determine whether the node is available.

In most cases, the `isAvailable` method does not need to be implemented, and the node is available by default. The most common need for this configuration is when a node may be a high-cost operation and is not suitable for workflow in a synchronous process. In this case, the `isAvailable` method can be used to restrict the use of the node. For example:

```ts
isAvailable({ engine, workflow, upstream, branchIndex }) {
  return !engine.isWorkflowSync(workflow);
}
```

### Learn More

For a detailed definition of each parameter in defining node types, refer to the [Workflow API Reference](./api#instruction-1) section.
