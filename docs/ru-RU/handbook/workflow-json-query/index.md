# JSON calculation

<PluginInfo name="workflow-json-query" link="/handbook/workflow-json-query" commercial="true"></PluginInfo>

This plugin is designed to transform or calculate complex JSON data generated by various nodes, enabling subsequent nodes to effectively utilize this data. For instance, SQL operations and HTTP request nodes often return results in JSON format. The JSON calculation node allows you to transform this data into the specific values and variable formats required by later stages in the workflow.

## User Manual

### Creating a Node

To add a "JSON calculation" node in the workflow configuration interface, simply click the plus (“+”) button within the process:

![Creating a Node](https://static-docs.nocobase.com/7de796517539ad9dfc88b7160f1d0dd7.png)

:::info{title=Tip}
JSON calculation nodes are generally positioned beneath other data nodes to facilitate parsing their output.
:::

### Node Configuration

#### Parsing Engine

The JSON calculation node offers support for various parsing engines, each with its own unique syntax. You can select an engine based on your specific needs and preferences. Currently, three parsing engines are available:

- [JMESPath](https://jmespath.org/)
- [JSONPath Plus](https://jsonpath-plus.github.io/JSONPath/docs/ts/)
- [JSONata](https://jsonata.org/)

![Parsing Engine Selection](https://static-docs.nocobase.com/29be3b92a62b7d20312d1673e749f2ec.png)

#### Data Source

The data source can be either the output of an upstream node or a data object within the process context. This is typically an unstructured data object, such as the results from an SQL node or an HTTP request node.

![Data Source](https://static-docs.nocobase.com/f5a97e20693b3d30b3a994a576aa282d.png)

:::info{title=Tip}
Data objects related to data tables are usually already structured through table configuration information and do not typically require parsing by a JSON calculation node.
:::

#### Parsing Expression

You can create a custom parsing expression based on your specific needs and the parsing engine you’ve selected.

![Parsing Expression](https://static-docs.nocobase.com/181abd162fd32c09b62f6aa1d1cb3ed4.png)

:::info{title=Tip}
Different parsing engines use different syntaxes; refer to the linked documentation for detailed information.
:::

As of version `v1.0.0-alpha.15`, expressions now support the use of variables. These variables are pre-parsed before the specific engine executes, replacing the variables with the corresponding string values according to string template rules and merging them with other static elements in the expression. This feature is particularly valuable when dynamically constructing expressions, such as when parsing JSON content that requires dynamic keys.

#### Properties mapping

When the parsed result is an object (or an array of objects), you can use properties mapping to convert the desired attributes into sub-variables for use by subsequent nodes.

![properties mapping](https://static-docs.nocobase.com/b876abe4ccf6b4709eb8748f21ef3527.png)

:::info{title=Tip}
For object (or array of objects) results, if you do not perform properties mapping, the entire object (or array of objects) will be stored as a single variable in the node's result, making it impossible to directly access the object's attribute values as individual variables.
:::

### Example

Suppose you need to parse data from an SQL node that returns a set of order data:

```json
[
  [
    {
      "id": 1,
      "products": [
        {
          "id": 1,
          "title": "Product 1",
          "price": 100,
          "quantity": 1
        },
        {
          "id": 2,
          "title": "Product 2",
          "price": 120,
          "quantity": 2
        }
      ]
    },
    {
      "id": 2,
      "products": [
        {
          "id": 3,
          "title": "Product 3",
          "price": 130,
          "quantity": 1
        },
        {
          "id": 4,
          "title": "Product 4",
          "price": 140,
          "quantity": 2
        }
      ]
    }
  ]
]
```

:::info{title=Tip}
The outer array in the code above is intentional; it reflects the typical output of an SQL node. This is because the SQL node’s result is a binary array, where the first element contains the query results and the second element contains metadata about the query.
:::

If you need to parse and calculate the total price for each order and assemble this data into an object with the corresponding order ID, ready to update the order's total price, you would configure it as follows:

![Example - SQL Parsing Configuration](https://static-docs.nocobase.com/e62322a868b26ff98120bfcd6dcdb3bd.png)

1. Select the JSONata parsing engine;
2. Choose the SQL node’s result as the data source;
3. Use the JSONata expression `$[0].{"id": id, "total": products.(price * quantity)}` for parsing;
4. Choose properties mapping to map `id` and `total` as sub-variables;

The final parsed result would look like this:

```json
[
  {
    "id": 1,
    "total": 340
  },
  {
    "id": 2,
    "total": 410
  }
]
```

You can then iterate over the array of completed orders to update the total price of each order.

![Update the Corresponding Order’s Total Price](https://static-docs.nocobase.com/b3329b0efe4471f5eed1f0673bef740e.png)
