# Печать по шаблону

<PluginInfo commercial="true" name="action-template-print"></PluginInfo>
<style>
.markdown h4 {
    font-size: 18px;
    font-weight: 500;
}
</style>

## Введение

Плагин **Печать по шаблону** — мощный инструмент, который позволяет редактировать шаблоны в форматах Word, Excel и PowerPoint 
(поддержка `.docx`, `.xlsx`, `.pptx`), настраивать плейсхолдеры и логические конструкции, а 
затем динамически генерировать предформатированные файлы (включая PDF). 
Плагин широко используется для создания коммерческих документов: коммерческих предложений, 
счетов, договоров и пр., существенно повышая скорость и точность подготовки документов.

### Основные возможности

- **Многоформатность**: Поддержка шаблонов Word, Excel и PowerPoint.
- **Динамическое заполнение данных**: Автоматическая генерация документа по плейсхолдерам и логике шаблона.
- **Гибкое управление шаблонами**: Возможность добавления, редактирования, удаления и категоризации шаблонов.
- **Богатый синтаксис шаблонов**: Поддержка подстановок, циклов, условий и других конструкций.
- **Поддержка форматирования**: Условия, форматирование дат и чисел для повышения читабельности и точности.
- **Удобный вывод**: Поддержка экспорта в PDF для печати и отправки.

## Установка

<embed src="./install.md"></embed>

## Инструкция по настройке

### Активация шаблонной печати

1. **Откройте блок с деталями**:
  - Перейдите в блок, где будет использоваться функция печати по шаблону.

2. **Откройте меню "Операции конфигурации"**:
  - В верхней части интерфейса нажмите на "Операции конфигурации".

3. **Выберите пункт "Печать по шаблону"**:
  - В выпадающем списке выберите "Печать по шаблону" для активации плагина.

![Активация шаблона](https://static-docs.nocobase.com/20241212150539-2024-12-12-15-05-43.png)

### Настройка шаблонов

1. **Откройте страницу конфигурации шаблона**:
  - В меню настройки кнопки "Печать по шаблону" выберите "Конфигурация шаблона".

![Пункт Конфигурации](https://static-docs.nocobase.com/20241212151858-2024-12-12-15-19-01.png)

2. **Добавьте новый шаблон**:
  - Нажмите "Добавить шаблон", чтобы открыть форму создания.

![Кнопка добавления шаблона](https://static-docs.nocobase.com/20241212151243-2024-12-12-15-12-46.png)

3. **Заполните информацию о шаблоне**:
  - Укажите название и тип (Word, Excel, PowerPoint).
  - Загрузите файл шаблона (`.docx`, `.xlsx`, `.pptx`).

![Настройка шаблона](https://static-docs.nocobase.com/20241212151518-2024-12-12-15-15-21.png)

4. **Отредактируйте и сохраните шаблон**:
  - Перейдите на вкладку "Список полей", скопируйте нужные и вставьте в шаблон.
    ![Список полей](https://static-docs.nocobase.com/20250107141010.png)
    ![Поле конфигурации](https://static-docs.nocobase.com/20241212152743-2024-12-12-15-27-45.png)
  - Нажмите "Сохранить", чтобы завершить добавление.

5. **Управление шаблонами**:
  - Нажмите "Использовать", чтобы активировать шаблон.
  - "Редактировать" — изменить название или заменить файл.
  - "Скачать" — загрузить шаблон.
  - "Удалить" — удалить шаблон (будет запрошено подтверждение).

![Управление шаблонами](https://static-docs.nocobase.com/20250107140436.png)

## Основной синтаксис

Плагин поддерживает разнообразный синтаксис для динамической генерации документов.

### Простая подстановка

Плейсхолдер `{d.xxx}` используется для подстановки значения из данных. Примеры:

- `{d.title}` — поле `title`.
- `{d.date}` — поле `date`.

**Пример**:

Шаблон:
```
Уважаемый клиент,

Спасибо что приобрели наш продукт: {d.productName}.
Номер заказа: {d.orderId}
Дата заказа: {d.orderDate}

Спасибо что остаетесь с нами!
```

Набор данных:
```json
{
  "productName": "Умные часы",
  "orderId": "A123456789",
  "orderDate": "2025-01-01"
}
```

Результат:
```
Уважаемый клиент,

Спасибо что приобрели наш продукт: Умные часы.
Номер заказа: A123456789
Дата заказа: 2025-01-01

Спасибо что остаетесь с нами!
```

### Доступ к вложенным объектам

Если в наборе данных содержатся вложенные объекты, вы можете получить доступ к их свойствам, 
используя точечную нотацию.

**Синтаксис**: `{d.parent.child}`

**Пример**:

Набор данных:
```json
{
  "customer": {
    "name": "Иван Петров",
    "contact": {
      "email": "ivan_petrov@nocobase.ru",
      "phone": "79019020000"
    }
  }
}
```

Шаблон:
```
Клиент: {d.customer.name}
Email: {d.customer.contact.email}
Телеофн: {d.customer.contact.phone}
```

Результат:
```
Клиент: Иван Петров
Email: ivan_petrov@nocobase.ru
Телеофн: 79019020000
```

### Доступ к массивам

Если в наборе данных содержатся массивы, вы можете использовать зарезервированное слово `i` 
для доступа к элементам массива.

**Синтаксис**: `{d.arrayName[i].field}`

**Пример**:

Набор данных:
```json
{
  "staffs": [
    { "firstname": "Андрей", "lastname": "Сембаев" },
    { "firstname": "Петр", "lastname": "Иванов" },
    { "firstname": "Нина", "lastname": "Добрых" }
  ]
}
```

Шаблон:
```
Первый сотрудник: фамилия — {d.staffs[i=0].lastname}, имя — {d.staffs[i=0].firstname}
```

Результат:
```
Первый сотрудник: фамилия — Сембаев, имя — Андрей
```

Below is the English translation with second-level and third-level headings:

## Обработка циклов

Обработка циклов используется для многократного отображения данных из массивов или объектов путём задания начальной и конечной метки для цикла. Ниже приведены несколько распространённых сценариев.

---

### Перебор массивов

#### 1. Описание синтаксиса

- Используйте тег `{d.array[i].property}` для обозначения текущего элемента в цикле, и `{d.array[i+1].property}` — для следующего элемента, чтобы определить границы области цикла.
- Во время выполнения цикла первая строка (`[i]` часть) автоматически используется как шаблон для повторения; вам нужно указать пример строки только один раз в шаблоне.

Пример синтаксиса:

```
{d.arrayName[i].property}
{d.arrayName[i+1].property}
```

#### 2. Пример: простой цикл по массиву

##### Данные

```json
{
  "cars": [
    { "brand": "Toyota", "id": 1 },
    { "brand": "Hyundai", "id": 2 },
    { "brand": "BMW",    "id": 3 },
    { "brand": "Peugeot","id": 4 }
  ]
}
```

##### Шаблон
```
МашиныID
{d.cars[i].brand}{d.cars[i].id}
{d.cars[i+1].brand}
```

##### Результат
```
МашиныID
Toyota1
Hyundai2
BMW3
Peugeot4
```

---

#### 3. Пример: Вложенный цикл по массиву

Подходит для случаев, когда массив содержит вложенные массивы; уровень вложенности может быть любым.

##### Данные

```json
[
  {
    "brand": "Toyota",
    "models": [
      { "size": "Prius 4", "power": 125 },
      { "size": "Prius 5", "power": 139 }
    ]
  },
  {
    "brand": "Kia",
    "models": [
      { "size": "EV4", "power": 450 },
      { "size": "EV6", "power": 500 }
    ]
  }
]
```

##### Шаблон
```
{d[i].brand}

Модель
{d[i].models[i].size} - {d[i].models[i].power}
{d[i].models[i+1].size}

{d[i+1].brand}
```

##### Результат
```
Toyota

Модель
Prius 4 - 125
Prius 5 - 139

Kia
```

---

#### 4. Пример: Двунаправленный цикл (расширенная функция, v4.8.0+)

Двунаправленные циклы позволяют выполнять итерацию одновременно по строкам и столбцам, 
что подходит для генерации таблиц сравнения и других сложных макетов 
(примечание: в настоящее время некоторые форматы официально поддерживаются только в шаблонах DOCX, HTML и MD).

##### Данные

```json
{
  "titles": [
    { "name": "Kia" },
    { "name": "Toyota" },
    { "name": "Hopium" }
  ],
  "cars": [
    { "models": [ "EV3", "Prius 1", "Prototype" ] },
    { "models": [ "EV4", "Prius 2", "" ] },
    { "models": [ "EV6", "Prius 3", "" ] }
  ]
}
```

##### Шаблон
```
{d.titles[i].name}{d.titles[i+1].name}
{d.cars[i].models[i]}{d.cars[i].models[i+1]}
{d.cars[i+1].models[i]}
```

##### Результат
```
KiaToyotaHopium
EV3Prius 1Prototype
EV4Prius 2
EV6Prius 3
```

---

#### 5. Пример: Доступ к значениям итератора в цикле (v4.0.0+)

Внутри цикла вы можете напрямую получить доступ к индексу текущей итерации, что помогает удовлетворить особые требования к форматированию.

##### Пример шаблона

```
{d[i].cars[i].other.wheels[i].tire.subObject:add(.i):add(..i):add(...i)}
```

> Примечание: Количество точек указывает уровень индекса (например, `.i` — текущий уровень, `..i` — предыдущий уровень). В настоящее время существует проблема с обратной сортировкой; пожалуйста, смотрите официальную документацию для получения подробностей.

---

### Перебор объектов

#### 1. Описание синтаксиса

- Для свойств в объекте используйте `.att`, чтобы получить имя свойства, и `.val`, чтобы получить значение свойства.
- Во время перебора каждый элемент свойства обрабатывается поочерёдно.

Пример синтаксиса:

```
{d.objectName[i].att}  // Имя
{d.objectName[i].val}  // Значение
```

#### 2. Пример: Перебор свойств объекта

##### Данные

```json
{
  "myObject": {
    "paul": "10",
    "jack": "20",
    "bob":  "30"
  }
}
```

##### Шаблон
```
Люди namePeople Возраст
{d.myObject[i].att}{d.myObject[i].val}
{d.myObject[i+1].att}{d.myObject[i+1].val}
```

##### Результат
```
Люди namePeople Возраст
paul10
jack20
bob30
```

---

### Сортировка

С помощью функции сортировки можно напрямую отсортировать данные массива в шаблоне.

#### 1. Описание синтаксиса: Сортировка по возрастанию

- Используйте атрибут в качестве критерия сортировки в теге цикла. Формат синтаксиса:

  ```
  {d.array[sortingAttribute, i].property}
  {d.array[sortingAttribute+1, i+1].property}
  ```
- Для нескольких критериев сортировки перечислите атрибуты через запятую в скобках.

#### 2. Пример: Сортировка по числовому атрибуту

##### Данные

```json
{
  "cars": [
    { "brand": "Ferrari", "power": 3 },
    { "brand": "Peugeot", "power": 1 },
    { "brand": "BMW",     "power": 2 },
    { "brand": "Lexus",   "power": 1 }
  ]
}
```

##### Шаблон
```
Машина
{d.cars[power, i].brand}
{d.cars[power+1, i+1].brand}
```

##### Результат
```
Cars
Peugeot
Lexus
BMW
Ferrari
```

#### 3. Пример: Сортировка по нескольким атрибутам

##### Данные

```json
{
  "cars": [
    { "brand": "Ferrari", "power": 3, "sub": { "size": 1 } },
    { "brand": "Aptera",  "power": 1, "sub": { "size": 20 } },
    { "brand": "Peugeot", "power": 1, "sub": { "size": 20 } },
    { "brand": "BMW",     "power": 2, "sub": { "size": 1 } },
    { "brand": "Kia",     "power": 1, "sub": { "size": 10 } }
  ]
}
```

##### Шаблон
```
Машины
{d.cars[power, sub.size, i].brand}
{d.cars[power+1, sub.size+1, i+1].brand}
```

##### Результат
```
Cars
Kia
Aptera
Peugeot
BMW
Ferrari
```

---

### Фильтрация

Фильтрация используется для исключения строк в цикле на основе заданных условий.

#### 1. Описание синтаксиса: Фильтрация по числовым значениям

- Добавьте условия в тег цикла (например, `age > 19`). Формат синтаксиса:

  ```
  {d.array[i, condition].property}
  ```

#### 2. Пример: Фильтрация по числовому значению

##### Данные

```json
[
  { "name": "John",   "age": 20 },
  { "name": "Eva",    "age": 18 },
  { "name": "Bob",    "age": 25 },
  { "name": "Charly", "age": 30 }
]
```

##### Шаблон
```
Люди
{d[i, age > 19, age < 30].name}
{d[i+1, age > 19, age < 30].name}
```

##### Результат
```
People
John
Bob
```

---

#### 3. Описание синтаксиса: Фильтрация строк

- Укажите условия строк, используя одинарные кавычки. Например:
  ```
  {d.array[i, type='rocket'].name}
  ```

#### 4. Пример: Фильтрация строк

##### Данные
```json
[
  { "name": "Falcon 9",    "type": "rocket" },
  { "name": "Model S",     "type": "car" },
  { "name": "Model 3",     "type": "car" },
  { "name": "Falcon Heavy","type": "rocket" }
]
```

##### Шаблон
```
Люди
{d[i, type='rocket'].name}
{d[i+1, type='rocket'].name}
```

##### Результат
```
Люди
Falcon 9
Falcon Heavy
```

---

#### 5. Описание синтаксиса: Фильтрация первых N элементов

- Вы можете использовать индекс цикла `i` для фильтрации первых N элементов. Например:
  ```
  {d.array[i, i < N].property}
  ```

#### 6. Пример: Фильтрация первых двух элементов

##### Данные
```json
[
  { "name": "Falcon 9" },
  { "name": "Model S" },
  { "name": "Model 3" },
  { "name": "Falcon Heavy" }
]
```

##### Шаблон
```
Люди
{d[i, i < 2].name}
{d[i+1, i < 2].name}
```

##### Результат
```
Люди
Falcon 9
Model S
```

---

#### 7. Описание синтаксиса: Исключить последние N элементов

- Используйте отрицательную индексацию `i` для представления элементов с конца. Например:
  - `{d.array[i=-1].property}` retrieves the last item.
  - `{d.array[i, i!=-1].property}` excludes the last item.

#### 8. Пример: Исключение последнего и последних двух элементов

##### Данные
```json
[
  { "name": "Falcon 9" },
  { "name": "Model S" },
  { "name": "Model 3" },
  { "name": "Falcon Heavy" }
]
```

##### Шаблон
```
Последний элемент: {d[i=-1].name}

Исключая последний элемент:
{d[i, i!=-1].name}
{d[i+1, i!=-1].name}

Исключая последние два элемента:
{d[i, i<-2].name}
{d[i+1, i<-2].name}
```

##### Результат
```
Последний элемент: Falcon Heavy

Исключая последний элемент:
Falcon 9
Model S
Model 3

Исключая последние два элемента:
Falcon 9
Model S
```

---

#### 9. Описание синтаксиса: интеллектуальная фильтрация

- Используя интеллектуальные блоки условий, вы можете скрыть целую строку на основе сложных условий. 
Например:
  ```
  {d.array[i].property:ifIN('keyword'):drop(row)}
  ```

#### 10. Пример: интеллектуальная фильтрация

##### Данные
```json
[
  { "name": "Falcon 9" },
  { "name": "Model S" },
  { "name": "Model 3" },
  { "name": "Falcon Heavy" }
]
```

##### Шаблон
```
Люди
{d[i].name}
{d[i].name:ifIN('Falcon'):drop(row)}
{d[i+1].name}
```

##### Результат
```
Люди
Model S
Model 3
```

*(Примечание: строки, содержащие «Falcon» в шаблоне, удаляются условием интеллектуальной фильтрации.)*

---

### Группировка

#### 1. Описание синтаксиса

- Используйте пользовательский итератор для группировки данных по указанному атрибуту и ​​применяйте агрегатный форматер (например, `aggSum`) для суммирования сгруппированных данных.
- Пример формата синтаксиса:
  ```
  {d.array[groupingAttribute].property}{d.array[groupingAttribute].quantity:aggSum(.groupingAttribute)}
  {d.array[groupingAttribute+1].property}
  ```

#### 2. Пример: Группировка по бренду и суммирование

##### Данные
```json
[
  { "brand": "Lucid",   "qty": 1 },
  { "brand": "Faraday", "qty": 4 },
  { "brand": "Venturi", "qty": 3 },
  { "brand": "Faraday", "qty": 2 },
  { "brand": "Aptera",  "qty": 1 },
  { "brand": "Lucid",   "qty": 10 }
]
```

##### Шаблон
```
VehiclesQuantity
{d[brand].brand}{d[brand].qty:aggSum(.brand)}
{d[brand+1].brand}
```

##### Результат
```
VehiclesQuantity
Aptera1
Faraday6
Lucid11
Venturi3
```

---

### Дедупликация

#### 1. Описание синтаксиса

- Используя пользовательский итератор, вы можете получить уникальные (не дублирующиеся) элементы на основе значения свойства. Синтаксис похож на обычный цикл, но автоматически игнорирует дублирующиеся элементы.

Пример формата:
```
{d.array[property].property}
{d.array[property+1].property}
```

#### 2. Пример: Выбор уникальных данных

##### Данные
```json
[
  { "type": "car",   "brand": "Hyundai" },
  { "type": "plane", "brand": "Airbus" },
  { "type": "plane", "brand": "Boeing" },
  { "type": "car",   "brand": "Toyota" }
]
```

##### Шаблон
```
Vehicles
{d[type].brand}
{d[type+1].brand}
```

##### Результат
```
Vehicles
Hyundai
Airbus
```
---


Below is the English translation of the documentation, with headings and subheadings preserved:

---

## Форматирование

Форматирование используют для преобразования необработанных данных в текст, который легко читать. Они применяются к данным с помощью двоеточия (`:`) и могут быть объединены в цепочку, так что вывод каждого форматирования становится вводом для следующего. Некоторые форматирование поддерживают постоянные параметры или динамические параметры.
---

### Обзор

#### 1. Объяснение синтаксиса
Базовый вызов форматера выглядит следующим образом:
```
{d.property:formatter1:formatter2(...)}
```  
Например, в случае преобразования строки `"JOHN"` в `"John"` сначала используется форматер `lowerCase` для преобразования всех букв в нижний регистр, а затем `ucFirst` используется для преобразования первой буквы в заглавную.
#### 2. Пример

Данные:
```json
{
  "name": "JOHN",
  "birthday": "2000-01-31"
}
```

Шаблон:
```
Меня зовут {d.name:lowerCase:ucFirst}. Я родился {d.birthday:formatD(LL)}.
```

#### 3. Результат

После рендеринга вывод будет таким:
```
Меня зовут Джон. Я родился 31 января 2000 года.
```

---

### Постоянные параметры

#### 1. Описание синтаксиса
Многие форматирования поддерживают один или несколько постоянных параметров, которые указываются в скобках и разделяются запятыми для изменения вывода. Например, `:prepend(myPrefix)` добавит «myPrefix» перед текстом.  
**Примечание:** Если параметр содержит запятые или пробелы, его необходимо заключать в одинарные кавычки, например: `prepend('my prefix')`.

#### 2. Пример

Пример шаблона (см. конкретное использование форматирования для деталей).

#### 3. Результат

Вывод будет содержать заданный префикс перед текстом.

---

### Динамические параметры

#### 1. Описание синтаксиса
Форматирование также поддерживают динамические параметры. Такие параметры начинаются с точки (`.`) и не заключаются в кавычки.  
Существует два способа указания динамических параметров:
- **Абсолютный путь JSON:** начинается с `d.` или `c.` (ссылается на корневые или дополнительные данные).
- **Относительный путь JSON:** начинается с одной точки (`.`), указывая на поиск свойства в текущем родительском объекте.

Например:

```
{d.subObject.qtyB:add(d.subObject.qtyC)}
```
Это также можно записать как относительный путь:
```
{d.subObject.qtyB:add(.qtyC)}
```
Если необходимо получить доступ к данным более высокого уровня (родительского и выше), можно использовать несколько точек:
```
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}
```

#### 2. Пример

Данные:

```json
{
  "id": 10,
  "qtyA": 20,
  "subObject": {
    "qtyB": 5,
    "qtyC": 3
  },
  "subArray": [{
    "id": 1000,
    "qtyE": 3
  }]
}
```

Использование в шаблоне:
```
{d.subObject.qtyB:add(d.subObject.qtyC)}      // Результат: 8 (5 + 3)
{d.subObject.qtyB:add(.qtyC)}                   // Результат: 8
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}        // Результат: 28 (5 + 20 + 3)
{d.subArray[0].qtyE:add(..subObject.qtyC)}       // Результат: 6 (3 + 3)
```

#### 3. Результат

Примеры дают 8, 8, 28 и 6 соответственно.

> **Примечание:** Использование пользовательских итераторов или фильтров массивов в качестве динамических параметров не допускается, например:
> ```
> {d.subObject.qtyB:add(..subArray[i].qtyE)}
> {d.subObject.qtyB:add(d.subArray[i].qtyE)}
> ```

---

### Форматирование текста

В этом разделе представлены различные методы форматирования текстовых данных. В следующих подразделах представлен синтаксис каждого форматировщика, примеры и результаты.

#### 1. :(Нижний регистр)lowerCase

##### Объяснение синтаксиса
Преобразует все буквы в нижний регистр.

##### Пример
```
'My Car':lowerCase()   // Вывод "my car"
'my car':lowerCase()   // Вывод "my car"
null:lowerCase()       // Вывод null
1203:lowerCase()       // Вывод 1203
```

##### Результат
Каждый пример выводит данные, указанные в комментариях.

---

#### 2. :Верхний регистр(upperCase)

##### Объяснение синтаксиса
Преобразует все буквы в верхний регистр.

##### Пример
```
'My Car':upperCase()   // Вывод "MY CAR"
'my car':upperCase()   // Вывод "MY CAR"
null:upperCase()       // Вывод null
1203:upperCase()       // Вывод 1203
```

##### Результат
Каждый пример выводит данные, указанные в комментариях.

---

#### 3. :Заглавная первая буква(ucFirst)

##### Объяснение синтаксиса
Делает заглавной только первую букву строки, оставляя остальные неизменными.

##### Пример
```
'My Car':ucFirst()     // Вывод "My Car"
'my car':ucFirst()     // Вывод "My car"
null:ucFirst()         // Вывод null
undefined:ucFirst()    // Вывод undefined
1203:ucFirst()         // Вывод 1203
```

##### Результат
Выход такой, как описано в комментариях.

---

#### 4. :Заглавная первая буква слова (ucWords)

##### Объяснение синтаксиса
Делает заглавной первую букву каждого слова в строке.

##### Пример
```
'my car':ucWords()     // Вывод "My Car"
'My cAR':ucWords()     // Вывод "My CAR"
null:ucWords()         // Вывод null
undefined:ucWords()    // Вывод undefined
1203:ucWords()         // Вывод 1203
```

##### Результат
Вывод такой же, как показано в примерах.

---

#### 5. :print(message)

##### Объяснение синтаксиса
Всегда возвращает указанное сообщение независимо от исходных данных, что делает его полезным в качестве резервного форматировщика.
Параметр:
- **message:** Текст для печати.

##### Пример
```
'My Car':print('hello!')   // Вывод  "hello!"
'my car':print('hello!')   // Вывод  "hello!"
null:print('hello!')       // Вывод  "hello!"
1203:print('hello!')       // Вывод  "hello!"
```

##### Результат
Возвращает указанную строку "hello!" во всех случаях.

---

#### 6. :printJSON

##### Объяснение синтаксиса
Преобразует объект или массив в строку в формате JSON.

##### Пример
```
[{'id':2,'name':'homer'},{'id':3,'name':'bart'}]:printJSON()
// Outputs "[
  {"id": 2, "name": "homer"},
  {"id": 3, "name": "bart"}
]"
'my car':printJSON()   // Outputs ""my car""
```

##### Результат
Выходные данные — строка в формате JSON с заданными данными.

---

#### 7. :unaccent

##### Объяснение синтаксиса
Удаляет диакритические знаки из текста, преобразуя его в формат без ударений.

##### Пример
```
'crÃ¨me brulÃ©e':unaccent()   // Outputs "creme brulee"
'CRÃME BRULÃE':unaccent()   // Outputs "CREME BRULEE"
'Ãªtre':unaccent()           // Outputs "etre"
'Ã©Ã¹Ã¯ÃªÃ¨Ã ':unaccent()       // Outputs "euieea"
```

##### Результат
Все примеры выводят текст с удаленными акцентами.

---

#### 8. :convCRLF

##### Объяснение синтаксиса
Преобразует символы возврата каретки и новой строки (`
` или `
`) в теги переноса строки, специфичные для документа. Это полезно для таких форматов, как DOCX, PPTX, ODT, ODP и ODS.
**Примечание:** При использовании `:html` перед `:convCRLF`, `
` будет преобразован в тег `<br>`.

##### Пример
```
// For ODT format:
'my blue 
 car':convCRLF()    // Outputs "my blue <text:line-break/> car"
'my blue 
 car':convCRLF()    // Outputs "my blue <text:line-break/> car"

// For DOCX format:
'my blue 
 car':convCRLF()    // Outputs "my blue </w:t><w:br/><w:t> car"
'my blue 
 car':convCRLF()    // Outputs "my blue </w:t><w:br/><w:t> car"
```

##### Результат
Вывод показывает маркеры переноса строки, соответствующие формату целевого документа.

---

#### 9. :substr(begin, end, wordMode)

##### Объяснение синтаксиса
Выполняет операции над подстроками в строке, начиная с индекса `begin` (начиная с 0) и заканчивая непосредственно перед индексом `end`.
Необязательный параметр `wordMode` (логический или `last`) управляет тем, следует ли избегать разрыва слова в середине.

##### Пример
```
'foobar':substr(0, 3)            // Outputs "foo"
'foobar':substr(1)               // Outputs "oobar"
'foobar':substr(-2)              // Outputs "ar"
'foobar':substr(2, -1)           // Outputs "oba"
'abcd efg hijklm':substr(0, 11, true)  // Outputs "abcd efg "
'abcd efg hijklm':substr(1, 11, true)  // Outputs "abcd efg "
```

##### Результат
Выходные данные — это подстрока, извлеченная в соответствии с параметрами.

---

#### 10. :split(delimiter)

##### Объяснение синтаксиса
Разбивает строку на массив, используя указанный разделитель.
Параметр:
- **delimiter:** Строка разделителя.

##### Пример
```
'abcdefc12':split('c')    // Outputs ["ab", "def", "12"]
1222.1:split('.')         // Outputs ["1222", "1"]
'ab/cd/ef':split('/')      // Outputs ["ab", "cd", "ef"]
```

##### Результат
Пример приводит к массиву, разделенному указанным разделителем.

---

#### 11. :padl(targetLength, padString)

##### Объяснение синтаксиса
Дополняет левую часть строки указанным символом, пока конечная строка не достигнет `targetLength`.
Если целевая длина меньше исходной длины строки, возвращается исходная строка.
Параметры:
- **targetLength:** Требуемая общая длина.
- **padString:** Строка, используемая для заполнения (по умолчанию — пробел).

##### Пример
```
'abc':padl(10)              // Outputs "       abc"
'abc':padl(10, 'foo')       // Outputs "foofoofabc"
'abc':padl(6, '123465')     // Outputs "123abc"
'abc':padl(8, '0')          // Outputs "00000abc"
'abc':padl(1)               // Outputs "abc"
```

##### Результат
Каждый пример выводит строку, дополненную слева соответствующим образом.

---

#### 12. :padr(targetLength, padString)

##### Объяснение синтаксиса
Дополняет правую часть строки указанным символом, пока конечная строка не достигнет `targetLength`.
Параметры такие же, как для `:padl`.

##### Пример
```
'abc':padr(10)              // Outputs "abc       "
'abc':padr(10, 'foo')       // Outputs "abcfoofoof"
'abc':padr(6, '123465')     // Outputs "abc123"
'abc':padr(8, '0')          // Outputs "abc00000"
'abc':padr(1)               // Outputs "abc"
```

##### Результат
Вывод показывает строку, дополненную справа.

---

#### 13. :ellipsis(maximum)

##### Объяснение синтаксиса
Если текст превышает указанное количество символов, добавляет многоточие ("...") в конце.
Параметр:
- **maximum:** Максимально допустимое количество символов.

##### Пример
```
'abcdef':ellipsis(3)      // Outputs "abc..."
'abcdef':ellipsis(6)      // Outputs "abcdef"
'abcdef':ellipsis(10)     // Outputs "abcdef"
```

##### Результат
В примерах показан текст, обрезанный и дополненный многоточием, если необходимо.

---

#### 14. :prepend(textToPrepend)

##### Объяснение синтаксиса
Добавляет указанный текст в начало строки.
Параметр:
- **textToPrepend:** Текст префикса.

##### Пример
```
'abcdef':prepend('123')     // Outputs "123abcdef"
```

##### Результат
Вывод показывает текст с указанным добавленным префиксом.

---

#### 15. :append(textToAppend)

##### Объяснение синтаксиса
Добавляет указанный текст в конец строки.
Параметр:
- **textToAppend:** Текст суффикса.

##### Пример
```
'abcdef':append('123')      // Outputs "abcdef123"
```

##### Результат
Вывод показывает текст с добавленным указанным суффиксом.

---

#### 16. :replace(oldText, newText)

##### Объяснение синтаксиса
Заменяет все вхождения `oldText` в тексте на `newText`.
Параметры:
- **oldText:** Текст для замены.
- **newText:** Новый текст для замены.
  **Примечание:** Если `newText` равен null, это означает, что соответствующий текст следует удалить.

##### Пример
```
'abcdef abcde':replace('cd', 'OK')    // Outputs "abOKef abOKe"
'abcdef abcde':replace('cd')          // Outputs "abef abe"
'abcdef abcde':replace('cd', null)      // Outputs "abef abe"
'abcdef abcde':replace('cd', 1000)      // Outputs "ab1000ef ab1000e"
```

##### Результат
Выход — текст после замены указанных сегментов.

---

#### 17. :len

##### Объяснение синтаксиса
Возвращает длину строки или массива.

##### Пример
```
'Hello World':len()     // Outputs 11
'':len()                // Outputs 0
[1,2,3,4,5]:len()       // Outputs 5
[1,'Hello']:len()       // Outputs 2
```

##### Результат
Выводит соответствующую длину в виде числа.

---

#### 18. :t

##### Объяснение синтаксиса
Переводит текст с использованием словаря перевода.
Примеры и результаты зависят от фактической конфигурации словаря перевода.

---

#### 19. :preserveCharRef

##### Объяснение синтаксиса
По умолчанию Template удаляет некоторые недопустимые символы из XML (такие как `&`, `>`, `<` и т. д.). Этот форматировщик сохраняет ссылки на символы (например, `&#xa7;` остается неизменным) и подходит для определенных сценариев генерации XML.
Примеры и результаты зависят от конкретного варианта использования.

---

### Форматирование чисел

#### 1. :formatN(precision)

##### Объяснение синтаксиса
Форматирует число в соответствии с настройками локализации.
Параметр:
- **precision:** Количество десятичных знаков.
  Для форматов ODS/XLSX количество отображаемых десятичных знаков определяется текстовым редактором; для других форматов используется этот параметр.

##### Пример
```
// Example environment: API options { "lang": "en-us" }
'10':formatN()         // Outputs "10.000"
'1000.456':formatN()   // Outputs "1,000.456"
```

##### Результат
Число выводится в соответствии с указанной точностью и форматом локализации.

---

#### 2. :round(precision)

##### Объяснение синтаксиса
Округляет число до указанного количества десятичных знаков.

##### Пример
```
10.05123:round(2)      // Outputs 10.05
1.05:round(1)          // Outputs 1.1
```

##### Результат
Выход — число, округленное до заданной точности.

---

#### 3. :add(value)

##### Объяснение синтаксиса
Добавляет указанное значение к текущему числу.
Параметр:
- **value:** Число для добавления.

##### Пример
```
1000.4:add(2)         // Outputs 1002.4
'1000.4':add('2')      // Outputs 1002.4
```

##### Результат
Выходные данные представляют собой сумму текущего числа и указанного значения.

---

#### 4. :sub(value)

##### Объяснение синтаксиса
Вычитает указанное значение из текущего числа.
Параметр:
- **value:** Число для вычитания.

##### Пример
```
1000.4:sub(2)         // Outputs 998.4
'1000.4':sub('2')      // Outputs 998.4
```

##### Результат
Выход — текущее число минус указанное значение.

---

#### 5. :mul(value)

##### Объяснение синтаксиса
Умножает текущее число на указанное значение.
Параметр:
- **value:** Множитель.

##### Пример
```
1000.4:mul(2)         // Outputs 2000.8
'1000.4':mul('2')      // Outputs 2000.8
```

##### Результат
Выход — это произведение текущего числа и указанного значения.

---

#### 6. :div(value)

##### Объяснение синтаксиса
Делит текущее число на указанное значение.
Параметр:
- **value:** Делитель.

##### Пример
```
1000.4:div(2)         // Outputs 500.2
'1000.4':div('2')      // Outputs 500.2
```

##### Результат
Выход — результат деления.

---

#### 7. :mod(value)

##### Объяснение синтаксиса
Вычисляет модуль (остаток) текущего числа, деленного на указанное значение.
Параметр:
- **value:** Делитель модуля.

##### Пример
```
4:mod(2)              // Outputs 0
3:mod(2)              // Outputs 1
```

##### Результат
Выход — остаток от операции модуля.

---

#### 8. :abs

##### Объяснение синтаксиса
Возвращает абсолютное значение числа.

##### Пример
```
-10:abs()             // Outputs 10
-10.54:abs()          // Outputs 10.54
10.54:abs()           // Outputs 10.54
'-200':abs()          // Outputs 200
```

##### Результат
Выходное значение — абсолютное значение входного числа.

---

#### 9. :ceil

##### Объяснение синтаксиса
Округляет число вверх до наименьшего целого числа, которое больше или равно текущему числу.

##### Пример
```
10.05123:ceil()       // Outputs 11
1.05:ceil()           // Outputs 2
-1.05:ceil()          // Outputs -1
```

##### Результат
Выходные данные — число, округленное в большую сторону до ближайшего целого числа.

---

#### 10. :floor

##### Объяснение синтаксиса
Округляет число в меньшую сторону до наибольшего целого числа, которое меньше или равно текущему числу.

##### Пример
```
10.05123:floor()      // Outputs 10
1.05:floor()          // Outputs 1
-1.05:floor()         // Outputs -2
```

##### Результат
Результат — число, округлённое меньшую сторону до ближайшего целого.

---

#### 11. :int

##### Описание синтаксиса
Преобразует число в целое (не рекомендуется к использованию).

##### Пример и результат
Зависит от конкретного случая преобразования.

---

#### 12. :toEN

##### Описание синтаксиса
Преобразует число в английский формат (использует `.` как разделитель дробной части). Не рекомендуется к использованию.

##### Пример и результат
Зависит от конкретного случая преобразования.

---

#### 13. :toFixed

##### Описание синтаксиса
Преобразует число в строку с сохранением указанного количества знаков после запятой. Не рекомендуется к использованию.

##### Пример и результат
Зависит от конкретного случая преобразования.

---

#### 14. :toFR

##### Описание синтаксиса
Преобразует число во французский формат (использует `,` как разделитель дробной части). Не рекомендуется к использованию.

##### Пример и результат
Зависит от конкретного случая преобразования.

---

### Форматирование валют

#### 1. :formatC(precisionOrFormat, targetCurrency)

##### Описание синтаксиса
Форматирует числовое значение как валюту и позволяет указать количество знаков после запятой или конкретный формат вывода.  
Параметры:
- **precisionOrFormat** — необязательный параметр: число (точность) или строка формата:
  - Целое число: задаёт количество знаков после запятой.
  - `'M'`: выводит только наименование валюты.
  - `'L'`: выводит число с символом валюты (по умолчанию).
  - `'LL'`: выводит число с полным названием валюты.
- **targetCurrency** — необязательный параметр: код целевой валюты в верхнем регистре (например, USD, EUR), который переопределяет глобальные настройки.

##### Пример
```
// Example environment: API options { "lang": "en-us", "currency": { "source": "EUR", "target": "USD", "rates": { "EUR": 1, "USD": 2 } } }
'1000.456':formatC()      // Outputs "$2,000.91"
'1000.456':formatC('M')    // Outputs "dollars"
'1':formatC('M')           // Outputs "dollar"
'1000':formatC('L')        // Outputs "$2,000.00"
'1000':formatC('LL')       // Outputs "2,000.00 dollars"

// French example (when environment settings differ):
'1000.456':formatC()      // Outputs "2 000,91 ..."  
'1000.456':formatC()      // When the source and target currencies are the same, outputs "1 000,46 €"
```

##### Результат
Выходные данные зависят от параметров API и настроек обменного курса.

---

#### 2. :convCurr(target, source)

##### Объяснение синтаксиса
Преобразует число из одной валюты в другую. Обменный курс можно передать через параметры API или задать глобально.
Если параметры не указаны, преобразование выполняется автоматически из `options.currencySource` в `options.currencyTarget`.
Параметры:
- **target:** Необязательно; код целевой валюты (по умолчанию `options.currencyTarget`).
- **source:** Необязательно; код исходной валюты (по умолчанию `options.currencySource`).

##### Пример
```
// Example environment: API options { "currency": { "source": "EUR", "target": "USD", "rates": { "EUR": 1, "USD": 2 } } }
10:convCurr()              // Outputs 20
1000:convCurr()            // Outputs 2000
1000:convCurr('EUR')        // Outputs 1000
1000:convCurr('USD')        // Outputs 2000
1000:convCurr('USD', 'USD') // Outputs 1000
```

##### Результат
Выходные данные — это преобразованное значение валюты.

---

### Форматирование даты

#### 1. :formatD(patternOut, patternIn)

##### Объяснение синтаксиса
Форматирует дату, принимая выходной формат `patternOut` и необязательный входной формат `patternIn` (по умолчанию ISO 8601).
Настройки часового пояса и языка можно выполнить с помощью `options.timezone` и `options.lang`.

##### Пример
```
// Example environment: API options { "lang": "en-us", "timezone": "Europe/Paris" }
'20160131':formatD('L')      // Outputs "01/31/2016"
'20160131':formatD('LL')     // Outputs "January 31, 2016"
'20160131':formatD('LLLL')   // Outputs "Sunday, January 31, 2016 12:00 AM"
'20160131':formatD('dddd')   // Outputs "Sunday"

// French example:
'2017-05-10T15:57:23.769561+03:00':formatD('LLLL')  // Outputs "mercredi 10 mai 2017 14:57"
'20160131':formatD('LLLL')   // Outputs "dimanche 31 janvier 2016 00:00"
1410715640:formatD('LLLL', 'X') // Outputs "dimanche 14 septembre 2014 19:27"
```

##### Результат
Вывод — дата, отформатированная указанным образом.

---

#### 2. :addD(amount, unit, patternIn)

##### Объяснение синтаксиса
Добавляет указанное количество времени к дате. Поддерживаемые единицы: день, неделя, месяц, квартал, год, час, минута, секунда, миллисекунда.
Параметры:
- **amount:** Количество для добавления.
- **unit:** Единица времени (без учета регистра).
- **patternIn:** Необязательно, формат ввода (по умолчанию ISO8601).

##### Пример
```
// Example environment: API options { "lang": "fr", "timezone": "Europe/Paris" }
'2017-05-10T15:57:23.769561+03:00':addD('3', 'day')    // Outputs "2017-05-13T12:57:23.769Z"
'2017-05-10 15:57:23.769561+03:00':addD('3', 'month')      // Outputs "2017-08-10T12:57:23.769Z"
'20160131':addD('3', 'day')       // Outputs "2016-02-03T00:00:00.000Z"
'20160131':addD('3', 'month')     // Outputs "2016-04-30T00:00:00.000Z"
'31-2016-01':addD('3', 'month', 'DD-YYYY-MM')  // Outputs "2016-04-30T00:00:00.000Z"
```

##### Результат
Выходные данные — новая дата после добавления указанного времени.

---

#### 3. :subD(amount, unit, patternIn)

##### Объяснение синтаксиса
Вычитает указанное количество времени из даты. Параметры такие же, как в `addD`.

##### Пример
```
// Example environment: API options { "lang": "fr", "timezone": "Europe/Paris" }
'2017-05-10T15:57:23.769561+03:00':subD('3', 'day')    // Outputs "2017-05-07T12:57:23.769Z"
'2017-05-10 15:57:23.769561+03:00':subD('3', 'month')      // Outputs "2017-02-10T12:57:23.769Z"
'20160131':subD('3', 'day')       // Outputs "2016-01-28T00:00:00.000Z"
'20160131':subD('3', 'month')     // Outputs "2015-10-31T00:00:00.000Z"
'31-2016-01':subD('3', 'month', 'DD-YYYY-MM')  // Outputs "2015-10-31T00:00:00.000Z"
```

##### Результат
Выходные данные — это новая дата после вычитания указанного времени.

---

#### 4. :startOfD(unit, patternIn)

##### Объяснение синтаксиса
Устанавливает дату на начало указанной единицы времени.
Параметры:
- **unit:** Единица времени.
- **patternIn:** Необязательно, формат ввода.

##### Пример
```
// Example environment: API options { "lang": "fr", "timezone": "Europe/Paris" }
'2017-05-10T15:57:23.769561+03:00':startOfD('day')    // Outputs "2017-05-10T00:00:00.000Z"
'2017-05-10 15:57:23.769561+03:00':startOfD('month')      // Outputs "2017-05-01T00:00:00.000Z"
'20160131':startOfD('day')       // Outputs "2016-01-31T00:00:00.000Z"
'20160131':startOfD('month')     // Outputs "2016-01-01T00:00:00.000Z"
'31-2016-01':startOfD('month', 'DD-YYYY-MM')  // Outputs "2016-01-01T00:00:00.000Z"
```

##### Результат
Выходные данные — это дата, установленная на начало указанной единицы.

---

#### 5. :endOfD(unit, patternIn)

##### Объяснение синтаксиса
Устанавливает дату на конец указанной единицы времени.
Параметры такие же, как для `startOfD`.

##### Пример
```
// Example environment: API options { "lang": "fr", "timezone": "Europe/Paris" }
'2017-05-10T15:57:23.769561+03:00':endOfD('day')    // Outputs "2017-05-10T23:59:59.999Z"
'2017-05-10 15:57:23.769561+03:00':endOfD('month')      // Outputs "2017-05-31T23:59:59.999Z"
'20160131':endOfD('day')       // Outputs "2016-01-31T23:59:59.999Z"
'20160131':endOfD('month')     // Outputs "2016-01-31T23:59:59.999Z"
'31-2016-01':endOfD('month', 'DD-YYYY-MM')  // Outputs "2016-01-31T23:59:59.999Z"
```

##### Результат
Выходные данные — дата, установленная на конец указанного блока.

---

#### 6. :diffD(toDate, unit, patternFromDate, patternToDate)

##### Объяснение синтаксиса
Вычисляет разницу между двумя датами и выводит ее в указанном блоке. Поддерживаемые блоки включают:
- `day(s)` or `d`
- `week(s)` or `w`
- `quarter(s)` or `Q`
- `month(s)` or `M`
- `year(s)` or `y`
- `hour(s)` or `h`
- `minute(s)` or `m`
- `second(s)` or `s`
- `millisecond(s)` or `ms` (default unit)

Параметры:
- **toDate:** Целевая дата.
- **unit:** Единица для вывода.
- **patternFromDate:** Необязательно, формат начальной даты.
- **patternToDate:** Необязательно, формат целевой даты.

##### Пример
```
'20101001':diffD('20101201')              // Outputs 5270400000
'20101001':diffD('20101201', 'second')      // Outputs 5270400
'20101001':diffD('20101201', 's')           // Outputs 5270400
'20101001':diffD('20101201', 'm')           // Outputs 87840
'20101001':diffD('20101201', 'h')           // Outputs 1464
'20101001':diffD('20101201', 'weeks')       // Outputs 8
'20101001':diffD('20101201', 'days')        // Outputs 61
'2010+10+01':diffD('2010=12=01', 'ms', 'YYYY+MM+DD', 'YYYY=MM=DD')  // Outputs 5270400000
```

##### Результат
Выходные данные — это разница во времени между двумя датами, преобразованная в указанную единицу.

---

#### 7. :convDate(patternIn, patternOut)

##### Объяснение синтаксиса
Преобразует дату из одного формата в другой (не рекомендуется для использования).
Параметры:
- **patternIn:** Формат входной даты.
- **patternOut:** Формат выходной даты.

##### Пример
```
// Example environment: API options { "lang": "en", "timezone": "Europe/Paris" }
'20160131':convDate('YYYYMMDD', 'L')      // Outputs "01/31/2016"
'20160131':convDate('YYYYMMDD', 'LL')     // Outputs "January 31, 2016"
'20160131':convDate('YYYYMMDD', 'LLLL')   // Outputs "Sunday, January 31, 2016 12:00 AM"
'20160131':convDate('YYYYMMDD', 'dddd')   // Outputs "Sunday"
1410715640:convDate('X', 'LLLL')          // Outputs "Sunday, September 14, 2014 7:27 PM"
// French example:
'20160131':convDate('YYYYMMDD', 'LLLL')   // Outputs "dimanche 31 janvier 2016 00:00"
'20160131':convDate('YYYYMMDD', 'dddd')   // Outputs "dimanche"
```

##### Результат
Выходные данные — дата, преобразованная в указанный формат.

---

#### 8. Шаблоны формата даты

Распространенные символы формата даты (см. документацию DayJS):
- `X`: Unix timestamp (in seconds), e.g., 1360013296
- `x`: Unix timestamp in milliseconds, e.g., 1360013296123
- `YY`: Two-digit year, e.g., 18
- `YYYY`: Four-digit year, e.g., 2018
- `M`, `MM`, `MMM`, `MMMM`: Month (number, two-digit, abbreviated, full name)
- `D`, `DD`: Day (number, two-digit)
- `d`, `dd`, `ddd`, `dddd`: Day of the week (number, minimal, abbreviated, full name)
- `H`, `HH`, `h`, `hh`: Hour (24-hour or 12-hour clock)
- `m`, `mm`: Minute
- `s`, `ss`: Second
- `SSS`: Millisecond (3 digits)
- `Z`, `ZZ`: UTC offset, e.g., +05:00 or +0500
- `A`, `a`: AM/PM
- `Q`: Quarter (1-4)
- `Do`: Day of month with ordinal, e.g., 1st, 2nd, …
- For other formats, refer to the full documentation.  
  Additionally, there are localized formats based on language such as `LT`, `LTS`, `L`, `LL`, `LLL`, `LLLL`, etc.

---

### Форматирование интервала

#### 1. :formatI(patternOut, patternIn)

##### Объяснение синтаксиса
Форматирует длительность или интервал. Поддерживаемые форматы вывода включают:
- `human+` или `human` (подходит для удобного отображения человеком)
- Единицы, такие как `миллисекунды`, `секунды`, `минуты`, `часы`, `годы`, `месяцы`, `недели`, `дни` (или их сокращения).

Параметры:
- **patternOut:** Формат вывода (например, `'секунда'` или `'human+'`).
- **patternIn:** Необязательно, единица ввода (например, `'миллисекунды'` или `'с'`).

##### Пример
```
// Example environment: API options { "lang": "en", "timezone": "Europe/Paris" }
2000:formatI('second')       // Outputs 2
2000:formatI('seconds')      // Outputs 2
2000:formatI('s')            // Outputs 2
3600000:formatI('minute')    // Outputs 60
3600000:formatI('hour')      // Outputs 1
2419200000:formatI('days')   // Outputs 28

// French example:
2000:formatI('human')        // Outputs "quelques secondes"
2000:formatI('human+')       // Outputs "dans quelques secondes"
-2000:formatI('human+')      // Outputs "il y a quelques secondes"

// English example:
2000:formatI('human')        // Outputs "a few seconds"
2000:formatI('human+')       // Outputs "in a few seconds"
-2000:formatI('human+')      // Outputs "a few seconds ago"

// Unit conversion example:
60:formatI('ms', 'minute')   // Outputs 3600000
4:formatI('ms', 'weeks')      // Outputs 2419200000
'P1M':formatI('ms')          // Outputs 2628000000
'P1Y2M3DT4H5M6S':formatI('hour')  // Outputs 10296.085
```

##### Result
The output is the duration or interval displayed in the specified unit or format.

---

### Форматирование массива

#### 1. :arrayJoin(separator, index, count)

##### Объяснение синтаксиса
Объединяет массив строк или чисел в одну строку.
Параметры:
- **separator:** Разделитель (по умолчанию запятая `,`).
- **index:** Необязательно; начальный индекс, с которого нужно объединить.
- **count:** Необязательно; количество элементов для объединения, начиная с `index` (может быть отрицательным для подсчета с конца).

##### Пример
```
['homer','bart','lisa']:arrayJoin()              // Outputs "homer, bart, lisa"
['homer','bart','lisa']:arrayJoin(' | ')          // Outputs "homer | bart | lisa"
['homer','bart','lisa']:arrayJoin('')              // Outputs "homerbartlisa"
[10,50]:arrayJoin()                               // Outputs "10, 50"
[]:arrayJoin()                                    // Outputs ""
null:arrayJoin()                                  // Outputs null
{}:arrayJoin()                                    // Outputs {}
20:arrayJoin()                                    // Outputs 20
undefined:arrayJoin()                             // Outputs undefined
['homer','bart','lisa']:arrayJoin('', 1)          // Outputs "bartlisa"
['homer','bart','lisa']:arrayJoin('', 1, 1)       // Outputs "bart"
['homer','bart','lisa']:arrayJoin('', 1, 2)       // Outputs "bartlisa"
['homer','bart','lisa']:arrayJoin('', 0, -1)      // Outputs "homerbart"
```

##### Результат
Выходные данные — строка, созданная путем объединения элементов массива в соответствии с указанными параметрами.

---

#### 2. :arrayMap(objSeparator, attSeparator, attributes)

##### Объяснение синтаксиса
Преобразует массив объектов в строку. Он не обрабатывает вложенные объекты или массивы.
Параметры:
- **objSeparator:** Разделитель между объектами (по умолчанию `, `).
- **attSeparator:** Разделитель между атрибутами объекта (по умолчанию `:`).
- **attributes:** Необязательно; список атрибутов объекта для вывода.

##### Пример
```
[{'id':2,'name':'homer'},{'id':3,'name':'bart'}]:arrayMap()
// Outputs "2:homer, 3:bart"

[{'id':2,'name':'homer'},{'id':3,'name':'bart'}]:arrayMap(' - ')
// Outputs "2:homer - 3:homer"

[{'id':2,'name':'homer'},{'id':3,'name':'bart'}]:arrayMap(' ; ', '|')
// Outputs "2|homer ; 3|bart"

[{'id':2,'name':'homer'},{'id':3,'name':'bart'}]:arrayMap(' ; ', '|', 'id')
// Outputs "2 ; 3"

[{'id':2,'name':'homer','obj':{'id':20},'arr':[12,23]}]:arrayMap()
// Outputs "2:homer"

['homer','bart','lisa']:arrayMap()    // Outputs "homer, bart, lisa"
[10,50]:arrayMap()                    // Outputs "10, 50"
[]:arrayMap()                         // Outputs ""
null:arrayMap()                       // Outputs null
{}:arrayMap()                         // Outputs {}
20:arrayMap()                         // Outputs 20
undefined:arrayMap()                  // Outputs undefined
```

##### Результат
Выходные данные представляют собой строку, сгенерированную путем сопоставления и объединения элементов массива, игнорируя содержимое вложенных объектов.

---

#### 3. :count(start)

##### Объяснение синтаксиса
Подсчитывает номер строки в массиве и выводит текущий номер строки.
Например:
```
{d[i].id:count()}
```  
Независимо от значения `id`, выводится текущий номер строки.  
Начиная с версии v4.0.0, это форматирование было заменено на `:cumCount`.

Параметр:
- **start** — необязательный параметр, задаёт начальное значение счётчика.

##### Пример и результат
В выводе будет отображаться номер строки в соответствии с порядком элементов массива.

---

## Условные конструкции

Условные конструкции позволяют динамически управлять отображением или скрытием содержимого документа на основе значений данных. Шаблон поддерживает три основных способа записи условий:

- **Встроенные условия**: Прямой вывод текста (или его замена другим).
- **Блоки условий**: Отображение или скрытие целых разделов документа, включая несколько тегов шаблона, абзацы, таблицы и т. д.

Все условия начинаются с логического форматтера (например, ifEQ, ifGT и др.), за которым следуют действия (например, show, elseShow, drop, keep и др.).

---

### Обзор

Поддерживаемые логические операторы и действия в условиях:

- **Логические операторы**
  - **ifEQ(value)**: Проверяет, равно ли значение указанному.
  - **ifNE(value)**: Проверяет, не равно ли значение указанному.
  - **ifGT(value)**: Проверяет, больше ли значение указанного.
  - **ifGTE(value)**: Проверяет, больше или равно указанному.
  - **ifLT(value)**: Проверяет, меньше ли значение указанного.
  - **ifLTE(value)**: Проверяет, меньше или равно указанному.
  - **ifIN(value)**: Проверяет, содержится ли значение в массиве или строке.
  - **ifNIN(value)**: Проверяет, не содержится ли значение в массиве или строке.
  - **ifEM()**: Проверяет, является ли значение пустым (например, null, undefined, пустая строка, массив или объект).
  - **ifNEM()**: Проверяет, не является ли значение пустым.
  - **ifTE(type)**: Проверяет, совпадает ли тип значения с указанным (например, "string", "number", "boolean" и т. д.).
  - **and(value)**: Логическое «и», используется для объединения нескольких условий.
  - **or(value)**: Логическое «или», используется для объединения нескольких условий.

- **Форматтеры действий**
  - **:show(text) / :elseShow(text)**: Используются во встроенных условиях для вывода указанного текста.
  - **:hideBegin / :hideEnd** и **:showBegin / :showEnd**: Используются в блоках условий для скрытия или отображения разделов документа.

Ниже представлены синтаксис, примеры и результаты для каждого типа использования.

---

### Встроенные условия

#### 1. :show(text) / :elseShow(text)

##### Синтаксис

```
{data:condition:show(text)}
{data:condition:show(text):elseShow(alternative text)}
```

##### Пример
Предположим, что данные:
```json
{
  "val2": 2,
  "val5": 5
}
```
Шаблон выглядит следующим образом:
```
val2 = {d.val2:ifGT(3):show('high')}
val2 = {d.val2:ifGT(3):show('high'):elseShow('low')}
val5 = {d.val5:ifGT(3):show('high')}
```

##### Результат
```
val2 = 2
val2 = low
val5 = high
```

---

#### 2. Switch Case (множественные условные операторы)

##### Синтаксис
Используйте последовательные форматировщики условий для создания структуры, похожей на switch-case:
```
{data:ifEQ(value1):show(result1):ifEQ(value2):show(result2):elseShow(default result)}
```
Или добиться того же самого с помощью оператора or:
```
{data:ifEQ(value1):show(result1):or(data):ifEQ(value2):show(result2):elseShow(default result)}
```

##### Пример
Данные:
```json
{
  "val1": 1,
  "val2": 2,
  "val3": 3
}
```
Шаблон:
```
val1 = {d.val1:ifEQ(1):show(A):ifEQ(2):show(B):elseShow(C)}
val2 = {d.val2:ifEQ(1):show(A):ifEQ(2):show(B):elseShow(C)}
val3 = {d.val3:ifEQ(1):show(A):ifEQ(2):show(B):elseShow(C)}
```

##### Результат
```
val1 = A
val2 = B
val3 = C
```

---

#### 3. Многопеременные условные операторы

##### Синтаксис
Используйте логические операторы и/или для проверки нескольких переменных:
```
{data1:ifEQ(condition1):and(.data2):ifEQ(condition2):show(result):elseShow(alternative result)}
{data1:ifEQ(condition1):or(.data2):ifEQ(condition2):show(result):elseShow(alternative result)}
```

##### Пример
Данные:
```json
{
  "val2": 2,
  "val5": 5
}
```
Шаблон:
```
and = {d.val2:ifEQ(1):and(.val5):ifEQ(5):show(OK):elseShow(KO)}
or = {d.val2:ifEQ(1):or(.val5):ifEQ(5):show(OK):elseShow(KO)}
```

##### Результат
```
and = KO
or = OK
```

---

### Логические операторы и форматирования

В следующих разделах описанные форматирования используют синтаксис встроенного условия со следующим форматом:
```
{data:formatter(parameter):show(text):elseShow(alternative text)}
```

#### 1. :and(значение)

##### Синтаксис
```
{data:ifEQ(value):and(new data or condition):ifGT(another value):show(text):elseShow(alternative text)}
```

##### Пример
```
{d.car:ifEQ('delorean'):and(.speed):ifGT(80):show('TravelInTime'):elseShow('StayHere')}
```

##### Результат
If `d.car` equals `'delorean'` and `d.speed` is greater than 80, the output is `TravelInTime`; otherwise, the output is `StayHere`.

---

#### 2. :or(значение)

##### Синтаксис
```
{data:ifEQ(value):or(new data or condition):ifGT(another value):show(text):elseShow(alternative text)}
```

##### Пример
```
{d.car:ifEQ('delorean'):or(.speed):ifGT(80):show('TravelInTime'):elseShow('StayHere')}
```

##### Результат
If `d.car` equals `'delorean'` or `d.speed` is greater than 80, the output is `TravelInTime`; otherwise, the output is `StayHere`.

---

#### 3. :ifEM()

##### Синтаксис
```
{data:ifEM():show(text):elseShow(alternative text)}
```

##### Пример
```
null:ifEM():show('Result true'):elseShow('Result false')
[]:ifEM():show('Result true'):elseShow('Result false')
```

##### Результат
Для `null` или пустого массива выводом будет `Result true`; в противном случае — `Result false`.

---

#### 4. :ifNEM()

##### Синтаксис
```
{data:ifNEM():show(text):elseShow(alternative text)}
```

##### Пример
```
0:ifNEM():show('Result true'):elseShow('Result false')
'homer':ifNEM():show('Result true'):elseShow('Result false')
```

##### Результат
Для непустых данных (например, числа 0 или строки «homer») выводится `Result true`; для пустых данных выводится `Result false`.
---

#### 5. :ifEQ(value)

##### Синтаксис
```
{data:ifEQ(value):show(text):elseShow(alternative text)}
```

##### Пример
```
100:ifEQ(100):show('Result true'):elseShow('Result false')
'homer':ifEQ('homer'):show('Result true'):elseShow('Result false')
```

##### Результат
Если данные равны указанному значению, то выводится «Результат true»; в противном случае — «Результат false».

---

#### 6. :ifNE(value)

##### Синтаксис
```
{data:ifNE(value):show(text):elseShow(alternative text)}
```

##### Пример
```
100:ifNE(100):show('Result true'):elseShow('Result false')
100:ifNE(101):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result false`, а второй пример выводит `Result true`.

---

#### 7. :ifGT(value)

##### Синтаксис
```
{data:ifGT(value):show(text):elseShow(alternative text)}
```

##### Пример
```
1234:ifGT(1):show('Result true'):elseShow('Result false')
-23:ifGT(19):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result true`, а второй выводит `Result false`.

---

#### 8. :ifGTE(value)

##### Синтаксис
```
{data:ifGTE(value):show(text):elseShow(alternative text)}
```

##### Пример
```
50:ifGTE(-29):show('Result true'):elseShow('Result false')
1:ifGTE(768):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result true`, а второй выводит `Result false`.

---

#### 9. :ifLT(value)

##### Синтаксис
```
{data:ifLT(value):show(text):elseShow(alternative text)}
```

##### Пример
```
-23:ifLT(19):show('Result true'):elseShow('Result false')
1290:ifLT(768):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result true`, а второй выводит `Result false`.

---

#### 10. :ifLTE(value)

##### Синтаксис
```
{data:ifLTE(value):show(text):elseShow(alternative text)}
```

##### Пример
```
5:ifLTE(5):show('Result true'):elseShow('Result false')
1290:ifLTE(768):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result true`, а второй выводит `Result false`.

---

#### 11. :ifIN(value)

##### Синтаксис
```
{data:ifIN(value):show(text):elseShow(alternative text)}
```

##### Пример
```
'car is broken':ifIN('is'):show('Result true'):elseShow('Result false')
[1,2,'toto']:ifIN(2):show('Result true'):elseShow('Result false')
```

##### Результат
Оба примера выводят `Result true` (потому что строка содержит `is', а массив содержит 2).

---

#### 12. :ifNIN(value)

##### Синтаксис
```
{data:ifNIN(value):show(text):elseShow(alternative text)}
```

##### Пример
```
'car is broken':ifNIN('is'):show('Result true'):elseShow('Result false')
[1,2,'toto']:ifNIN(2):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result false` (потому что строка содержит 'is'), а второй пример выводит `Result false` (потому что массив содержит 2).

---

#### 13. :ifTE(type)

##### Синтаксис
```
{data:ifTE('type'):show(text):elseShow(alternative text)}
```

##### Пример
```
'homer':ifTE('string'):show('Result true'):elseShow('Result false')
10.5:ifTE('number'):show('Result true'):elseShow('Result false')
```

##### Результат
Первый пример выводит `Result true` (поскольку 'homer' — это строка), а второй выводит `Result true` (поскольку 10.5 — это число).
---

### Условные блоки

Условные блоки используются для отображения или скрытия раздела документа, как правило, для заключения нескольких тегов или целого блока текста.

#### 1. :showBegin / :showEnd

##### Синтаксис
```
{data:ifEQ(condition):showBegin}
Document block content
{data:showEnd}
```

##### Пример
Данные:
```json
{
  "toBuy": true
}
```
Шаблон:
```
Banana{d.toBuy:ifEQ(true):showBegin}
Apple
Pineapple
{d.toBuy:showEnd}Grapes
```

##### Результат
При выполнении условия отображается содержимое между ними:
```
Banana
Apple
Pineapple
Grapes
```

---

#### 2. :hideBegin / :hideEnd

##### Синтаксис
```
{data:ifEQ(condition):hideBegin}
Document block content
{data:hideEnd}
```

##### Пример
Данные:
```json
{
  "toBuy": true
}
```
Шаблон:
```
Banana{d.toBuy:ifEQ(true):hideBegin}
Apple
Pineapple
{d.toBuy:hideEnd}Grapes
```

##### Результат
При выполнении условия содержимое между ними скрывается, что приводит к следующему:
```
Banana
Grapes
```

## Вычисление

### Простые математические операции

#### 1. :add(value)
##### Синтаксис
```
{data: add(value)}
```
##### Пример
Предположим, что данные:
```json
{
  "num": 10
}
```
Шаблон:
```
{d.num:add(5)}
```
##### Результат
Выводит 15, что является результатом 10 + 5.

---

#### 2. :mul(значение)
##### Синтаксис
```
{data: mul(value)}
```
##### Пример
Данные:
```json
{
  "num": 10
}
```
Шаблон:
```
{d.num:mul(3)}
```
##### Результат
Выводит 30, что является результатом 10 × 3.

---

#### 3. :sub(значение)
##### Синтаксис
```
{data: sub(value)}
```
##### Пример
Данные:
```json
{
  "num": 10
}
```
Шаблон:
```
{d.num:sub(4)}
```
##### Результат
Выходы 6, что является результатом 10 - 4.

---

#### 4. :div(значение)
##### Синтаксис
```
{data: div(value)}
```
##### Пример
Данные:
```json
{
  "num": 10
}
```
Шаблон:
```
{d.num:div(2)}
```
##### Результат
Выход 5, что является результатом 10 / 2.

---

#### 5. :mod(значение)
##### Синтаксис
```
{data: mod(value)}
```
##### Пример
Данные:
```json
{
  "num": 10
}
```
Шаблон:
```
{d.num:mod(3)}
```
##### Результат
На выходе получается 1, что является остатком от деления 10 на 3.

---

#### 6. :abs()
##### Синтаксис
```
{data: abs()}
```
##### Пример
Данные:
```json
{
  "value": -23
}
```
Шаблон:
```
{d.value:abs}
```
##### Результат
Выводит 23, что является абсолютным значением -23.

---

#### 7. Расчет математических выражений
Поддерживает написание простых математических выражений внутри скобок (разрешены только операторы +, -, *, /, а вложенные скобки не допускаются).
Порядок операций следует за умножением и делением перед сложением и вычитанием.

##### Синтаксис
```
{data: add(.other + .vat * d.sub.price - 10 / 2)}
```
##### Пример
Данные:
```json
{
  "val": 1,
  "other": 2,
  "vat": 0.5,
  "sub": {
    "price": 100
  }
}
```
Шаблон:
```
{d.val:add(.other + .vat * d.sub.price - 10 / 2)}
```
##### Результат
Вывод 48.

---

## Расширенные возможности

### Нумерация страниц

#### 1. Обновление номера страницы

##### Синтаксис
Просто вставьте соответствующее поле в вашем офисном редакторе.

##### Пример
В Microsoft Word:
- Используйте меню «Вставка → Номер страницы»

В LibreOffice:
- Используйте меню «Вставка → Поле → Номер страницы»

##### Результат
В сгенерированном отчёте номера страниц будут обновляться автоматически.

---

#### 2. Генерация оглавления

##### Синтаксис
Просто вставьте оглавление в вашем офисном редакторе.

##### Пример
В Microsoft Word:
- Используйте меню «Вставка → Указатели и таблицы → Оглавление»

В LibreOffice:
- Используйте меню «Вставка → Оглавление и указатель → Оглавление, указатель или библиография»

##### Результат
Оглавление в отчёте будет автоматически обновляться на основе содержания документа.

---

#### 3. Повтор заголовков таблицы

##### Синтаксис
Просто настройте повтор заголовка в вашем офисном редакторе.

##### Пример
В Microsoft Word:
- Щёлкните правой кнопкой мыши по заголовку таблицы → Свойства таблицы → Установите флажок «Повторять как строку заголовка в начале каждой страницы»

В LibreOffice:
- Щёлкните правой кнопкой мыши по заголовку таблицы → Свойства таблицы → Вкладка «Размещение текста» → Установите флажок «Повторить заголовок»

##### Результат
Если таблица переходит на следующую страницу, заголовок будет автоматически повторяться на каждой странице.

---

### Интернационализация (i18n)

#### 1. Перевод статического текста

##### Синтаксис
Используйте тег `{t(text)}` для интернационализации статического текста:

```
{t(meeting)}
```

##### Пример
В шаблоне:
```
{t(meeting)} {t(apples)}
```
Данные JSON или внешний словарь локализации (например, для «fr-fr») предоставляют соответствующие переводы (например, «meeting» → «rendez-vous» и «apples» → «Pommes»).

##### Результат
При формировании отчета текст будет заменен соответствующим переводом на основе целевого языка.

---

#### 2. Динамический перевод текста

##### Синтаксис
Для содержимого данных используйте форматер `:t`, например:
```
{d.id:ifEQ(2):show({t(monday)}):elseShow({t(tuesday)})}
```

##### Пример
В шаблоне:
```
{d.id:ifEQ(2):show({t(monday)}):elseShow({t(tuesday)})}
```
Данные JSON и словарь локализации предоставляют соответствующие переводы.

##### Результат
В зависимости от условия вывод будет либо «lundi», либо «mardi» (используя целевой язык в качестве примера).

---

### Сопоставление ключ-значение

#### 1. Преобразование перечисления (:convEnum)

##### Синтаксис
```
{data:convEnum(enumName)}
```
Для примера:
```
0:convEnum('ORDER_STATUS')
```

##### Пример
В примере параметров API указано следующее:
```json
{
  "enum": {
    "ORDER_STATUS": ["pending", "sent", "delivered"]
  }
}
```
В шаблоне:
```
0:convEnum('ORDER_STATUS')
```

##### Результат
Выводит «ожидание»; если индекс превышает диапазон перечисления, выводится исходное значение.

---
